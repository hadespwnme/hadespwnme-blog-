---
layout: post
title: "laCTF 2026 - Reverse Engineering"
date: 2026-02-07
image: /assets/.
categories: ["laCTF"]
tags: [rev, dos, lfsr, ctf2026]
---


## Flag Finder

### Intro

Kadang reverse itu bukan tentang “baca assembly sampai mata berair(pengen nangis)”, tapi tentang *ngeliat pola* yang disembunyiin di tempat yang gak nyangka.

Di challenge ini, judulnya santai: **Flag Finder**. UI-nya juga “ramah”: grid kotak-kotak(**ascii art**), tombol **Find flag**. Tapi begitu kita intip file JavaScript-nya… ternyata validasi “flag” dilakukan pakai **regex raksasa**.

Dan twist-nya: regex itu bukan buat string biasa.
Dia sebenarnya **Nonogram (Picross)** yang disamarkan jadi regex.

Target akhir kita: bikin pola `#` dan `.` yang **lulus regex**, lalu baca teks yang kebentuk jadi flag.

---

### Recon: layanan apa yang dibuka?

Host yang dikasih(karena biasanya rev itu pake *nc* dan gak di kasih port jadi scan port pilihan yang tepat):

```bash
flag-finder.chall.lac.tf
```

Mulai dari scan port yang relevan:

```bash
$ nmap -Pn -p 22,80,443,1337,31337 flag-finder.chall.lac.tf
Starting Nmap 7.98 ( https://nmap.org )
Nmap scan report for flag-finder.chall.lac.tf (34.11.215.13)
Host is up (0.18s latency).
Not shown: 3 filtered tcp ports (no-response)
PORT    STATE SERVICE
80/tcp  open  http
443/tcp open  https
```

Jadi ini web.

Cek landing page:

```bash
$ curl -fsSL -D - http://flag-finder.chall.lac.tf/ | head
HTTP/1.1 200 OK
Content-Type: text/html
Server: nginx/1.29.5

<!DOCTYPE html>
<html lang="en">
```

HTML-nya include `script.js`:

```html
<script src="script.js"></script>
```

Ambil script-nya:

```bash
$ curl -fsSL http://flag-finder.chall.lac.tf/script.js -o /tmp/ff_script.js
$ head -n 25 /tmp/ff_script.js
```

---

### Bedah `script.js`: “flag” nya bukan string biasa

Potongan source intinya:

```js
const len = 1919;
const theFlag = /^ ... $/;

function match() {
  const boxes = document.querySelectorAll('.grid-box');
  let input = "";
  boxes.forEach(box => {
    input += box.checked ? "#" : ".";
  });

  if (theFlag.test(input)) {
    result.textContent = "✅ Flag found!";
  } else {
    result.textContent = "❌ Flag not found.";
  }
}
```

Insight-nya:

- Ada **1919 checkbox** → artinya input adalah string panjang 1919.
- Tiap checkbox jadi karakter:
  - checked → `#`
  - unchecked → `.`
- Jadi yang dicari adalah **pola** `#` / `.` sepanjang 1919 karakter.

Kalau kita faktor 1919:

- `1919 = 19 * 101`

Ini bau banget: grid **19 baris x 101 kolom**.

---

### Inti exploit: regex itu sebenarnya “aturan Nonogram”

#### 1) Nonogram singkatnya apa?

Nonogram itu puzzle gambar dari grid hitam/putih.
Kamu dikasih **clue** untuk:

- setiap baris → daftar panjang “blok hitam” (`#`) berurutan
- setiap kolom → daftar panjang “blok hitam” (`#`) berurutan

Contoh clue baris `[3,1]` artinya:

- ada 3 `#` berurutan,
- minimal 1 `.`,
- lalu 1 `#`.

Nah… challenge ini encode clue itu ke regex.

#### 2) Gimana regex encode baris?

Di bagian akhir regex ada pola seperti:

```
(?<=.{101})(?<!.{102})(\.*#{2}\.+#\.+#{2} ... )
```

Ini artinya:

- `(?<=.{101})(?<!.{102})` → *anchor* supaya kita lagi berada tepat di batas baris.
- grup `\.*#{2}\.+#...` → ini literally menggambarkan “run” `#`:
  - `#{2}` → dua `#` berurutan
  - `\.+` → minimal satu `.` sebagai pemisah antar blok

Jadi, kalau kita parse `#{k}` dan `#` biasa, kita dapat clue baris.

#### 3) Gimana regex encode kolom?

Di bagian awal regex, ada banyak lookahead `(?=...)` yang bentuknya repetitif:

- `(?:.{c}\..{100-c})` → “di kolom ke-`c` harus `.` untuk suatu baris tertentu”
- `(?:.{c}#.{100-c})` → “di kolom ke-`c` harus `#` untuk suatu baris tertentu”

Ketika bagian ini dikombinasi dengan pengulangan `(...){n}` dan `(...)+`, itu persis memaksa pattern `#`/`.` vertikal → clue kolom.

Kesimpulan: regex raksasa itu bukan “validator string”.
Dia adalah **solver Nonogram yang di reverse**: dia memvalidasi grid yang benar.

---

### Solver: parse regex → jadi clue → solve pakai Z3

Aku bikin solver yang melakukan 4 langkah:

1. Ambil regex `theFlag` dari `/tmp/ff_script.js`
2. Extract **row clues** dan **column clues** dari struktur regex
3. Solve Nonogram pakai **Z3** (SMT solver)
4. Decode hasil gambar (font 3x5) menjadi string flag

#### Setup

```bash
$ cd /home/hadespwnme/ctf/lactf/rev/flag-finder
$ python3 -m venv .venv
$ . .venv/bin/activate
$ pip install z3-solver==4.13.0.0

# simpan JS target (biar solver bisa parse regex-nya)
$ curl -fsSL http://flag-finder.chall.lac.tf/script.js -o /tmp/ff_script.js

$ python solve.py | tail -n 4
--- decoded flag
lactf{Wh47_d0_y0u_637_wh3n_y0u_cr055_4_r363x_4nd_4_n0n06r4m?_4_r363x06r4m!}
```

### Kode solver

```py
"""LA CTF - Flag Finder

The challenge serves a web page with 1919 checkboxes (a 19x101 grid).
The client-side JS checks the checkbox pattern against a giant regex.

That giant regex is (effectively) a Nonogram constraint:
- a lookahead per *column* encodes the column clue runs
- a sequence of groups encodes the *row* clue runs

This solver:
1) parses the regex out of the hosted script.js
2) extracts row/column Nonogram clues
3) solves the Nonogram with Z3
4) decodes the resulting 3x5 font into the flag string
"""

import re
import sys
from pathlib import Path


def find_matching_paren(text: str, start_idx: int) -> int:
    """Find the matching ')' for '(' at start_idx, respecting escapes."""
    if text[start_idx] != '(':
        raise ValueError('expected ( at start_idx')
    depth = 0
    i = start_idx
    while i < len(text):
        c = text[i]
        if c == '\\':
            i += 2
            continue
        if c == '(':
            depth += 1
        elif c == ')':
            depth -= 1
            if depth == 0:
                return i
        i += 1
    raise ValueError('no matching ) found')


def prefix_str(n: int) -> str:
    """Regex fragment for skipping n chars."""
    if n == 0:
        return ''
    if n == 1:
        return '.'
    return f'.{{{n}}}'


def suffix_str(n: int) -> str:
    """Regex fragment for skipping n chars."""
    if n == 0:
        return ''
    if n == 1:
        return '.'
    return f'.{{{n}}}'


def token(col: int, ch: str) -> str:
    """Column-constraint token used by the challenge regex."""
    rest = 100 - col
    pref = prefix_str(col)
    suff = suffix_str(rest)
    if ch == '.':
        return f'(?:{pref}\\.{suff})'
    if ch == '#':
        return f'(?:{pref}#{suff})'
    raise ValueError('ch must be . or #')


def get_col_from_expr(expr: str) -> int:
    """Infer which column a lookahead refers to from its first token."""
    i = expr.find('(?:')
    if i == -1:
        raise ValueError('no (?: in expr')
    j = i + 3

    if expr.startswith('\\.', j) or expr.startswith('#', j):
        return 0
    if expr.startswith('.', j):
        if expr.startswith('\\.', j + 1) or expr.startswith('#', j + 1):
            return 1
        if expr.startswith('{', j + 1):
            k = expr.find('}', j + 2)
            return int(expr[j + 2 : k])
    if expr.startswith('.{', j):
        k = expr.find('}', j + 2)
        return int(expr[j + 2 : k])

    raise ValueError(f'cannot infer column from expr prefix: {expr[:80]!r}')


def simplify_expr(expr: str, col: int) -> str:
    """Replace the verbose per-column tokens with just '.' or '#'."""
    return expr.replace(token(col, '.'), '.').replace(token(col, '#'), '#')


def runs_from_expr(expr: str) -> list[int]:
    """Parse a row/col clue from a run-encoded regex fragment."""
    runs: list[int] = []
    i = 0
    while i < len(expr):
        if expr[i] == '#':
            if i + 1 < len(expr) and expr[i + 1] == '{':
                j = expr.find('}', i + 2)
                runs.append(int(expr[i + 2 : j]))
                i = j + 1
            else:
                runs.append(1)
                i += 1
        else:
            i += 1
    return runs


def extract_regex_from_script(script_text: str) -> str:
    """Grab the huge /^(... )$/ regex body from script.js."""
    m = re.search(r'theFlag\\s*=\\s*/\\^(.+?)\\$\\/;\\s*\\n', script_text, flags=re.S)
    if not m:
        raise ValueError('could not locate theFlag regex in script')
    return m.group(1)


def extract_column_clues(pre: str) -> list[list[int]]:
    """Parse the 101 column lookaheads into Nonogram run lists."""
    outer_end = find_matching_paren(pre, 0)
    inner = pre[3:outer_end]

    lookaheads: list[str] = []
    i = 0
    while i < len(inner):
        if inner.startswith('(?=', i):
            end = find_matching_paren(inner, i)
            lookaheads.append(inner[i + 3 : end])
            i = end + 1
        else:
            i += 1

    if len(lookaheads) != 101:
        raise ValueError(f'expected 101 column lookaheads, got {len(lookaheads)}')

    col_expr: dict[int, str] = {}
    for expr in lookaheads:
        col = get_col_from_expr(expr)
        if col in col_expr:
            raise ValueError(f'duplicate column {col}')
        col_expr[col] = expr

    missing = set(range(101)) - set(col_expr)
    if missing:
        raise ValueError(f'missing columns: {sorted(missing)}')

    clues: list[list[int]] = []
    for col in range(101):
        simp = simplify_expr(col_expr[col], col)
        clues.append(runs_from_expr(simp))
    return clues


def extract_row_clues(post: str) -> list[list[int]]:
    """Parse the 19 row groups into Nonogram run lists."""
    groups: list[str] = []

    if not post.startswith('('):
        raise ValueError('expected first row group at start of post')
    end = find_matching_paren(post, 0)
    groups.append(post[1:end])
    i = end + 1

    boundary_re = re.compile(r'\\(\\?<=\\.\\{(\\d+)\\}\\)\\(\\?<\\!\\.\\{(\\d+)\\}\\)')
    while True:
        m = boundary_re.search(post, i)
        if not m:
            break
        i = m.end()
        if i < len(post) and post[i] == '(':
            end = find_matching_paren(post, i)
            groups.append(post[i + 1 : end])
            i = end + 1
        else:
            break

    if len(groups) != 19:
        raise ValueError(f'expected 19 row groups, got {len(groups)}')

    return [runs_from_expr(g) for g in groups]


def solve_nonogram(row_clues: list[list[int]], col_clues: list[list[int]]):
    """Solve the Nonogram as constraints over booleans using Z3."""
    import z3

    H = len(row_clues)
    W = len(col_clues)

    # x[r][c] == True means a filled cell ('#')
    x = [[z3.Bool(f'x_{r}_{c}') for c in range(W)] for r in range(H)]
    s = z3.Solver()

    def add_line_constraints(cells, runs, name_prefix: str):
        """Enforce run-length constraints on one line (row/col)."""
        L = len(cells)
        k = len(runs)

        if k == 0:
            for p in range(L):
                s.add(cells[p] == z3.BoolVal(False))
            return

        # start indices for each run
        starts = [z3.Int(f'{name_prefix}_s{i}') for i in range(k)]

        # bounds + ordering (+ at least 1 gap between runs)
        for i_run, run_len in enumerate(runs):
            s.add(starts[i_run] >= 0)
            s.add(starts[i_run] + run_len <= L)
            if i_run > 0:
                prev_len = runs[i_run - 1]
                s.add(starts[i_run] >= starts[i_run - 1] + prev_len + 1)

        # each position is filled iff it belongs to any run interval
        for p in range(L):
            in_any = z3.Or(
                [z3.And(starts[i_run] <= p, p < starts[i_run] + runs[i_run]) for i_run in range(k)]
            )
            s.add(cells[p] == in_any)

    for r in range(H):
        add_line_constraints(x[r], row_clues[r], f'row{r}')

    for c in range(W):
        add_line_constraints([x[r][c] for r in range(H)], col_clues[c], f'col{c}')

    if s.check() != z3.sat:
        raise RuntimeError('unsat')

    m = s.model()
    grid = [[bool(m.evaluate(x[r][c], model_completion=True)) for c in range(W)] for r in range(H)]
    return grid


def render(grid: list[list[bool]]) -> str:
    """Pretty print for humans."""
    lines = []
    for row in grid:
        lines.append(''.join('█' if v else ' ' for v in row))
    return '\n'.join(lines)


def decode_flag_from_grid(grid: list[list[bool]]) -> str:
    """Decode the 3x5 glyph text drawn by the solved grid."""
    H = len(grid)
    W = len(grid[0]) if H else 0
    if (H, W) != (19, 101):
        raise ValueError(f'unexpected grid size {(H, W)}, expected (19, 101)')

    def pat_for(line_start: int, glyph_idx: int) -> tuple[str, ...]:
        cols = [4 * glyph_idx + 1, 4 * glyph_idx + 2, 4 * glyph_idx + 3]
        rows = range(line_start + 1, line_start + 6)  # 5-row font
        return tuple(''.join('#' if grid[r][c] else '.' for c in cols) for r in rows)

    font: dict[tuple[str, ...], str] = {
        ("##.", ".#.", ".#.", ".#.", "###"): "l",
        ("...", "##.", ".##", "#.#", "###"): "a",
        ("...", ".##", "#..", "#..", ".##"): "c",
        (".#.", "###", ".#.", ".#.", ".##"): "t",
        (".##", ".#.", "###", ".#.", ".#."): "f",
        (".##", "##.", "#..", "##.", ".##"): "{",
        ("#.#", "#.#", "###", "###", "#.#"): "W",
        ("#.#", "#.#", "###", "..#", "..#"): "4",
        ("###", "..#", "..#", "..#", "..#"): "7",
        ("..#", ".##", "#.#", "#.#", ".##"): "d",
        ("...", "...", "...", "...", "###"): "_",
        (".##", "#.#", "#.#", "#.#", "###"): "0",
        ("...", "#.#", "#.#", "#.#", ".##"): "u",
        (".##", "#..", "###", "#.#", "###"): "6",
        ("#..", "##.", "#.#", "#.#", "#.#"): "h",
        ("###", "..#", "###", "..#", "###"): "3",
        ("...", "###", "#.#", "#..", "#.."): "r",
        ("###", "#..", "###", "..#", "##."): "5",
        ("...", "##.", "#.#", "#.#", "#.#"): "n",
        ("...", "#.#", "#.#", "###", "..#"): "y",
        ("...", "###", "###", "###", "#.#"): "m",
        ("...", "#.#", ".#.", ".#.", "#.#"): "x",
        ("...", "#.#", "###", "###", "###"): "w",
        ("###", "..#", ".#.", "...", ".#."): "?",
        ("##.", ".##", "..#", ".##", "##."): "}",
        (".#.", ".#.", ".#.", "...", ".#."): "!",
    }

    decoded = []
    for line_start in (0, 6, 12):
        for glyph_idx in range(25):
            pat = pat_for(line_start, glyph_idx)
            if pat not in font:
                raise ValueError('unknown glyph pattern')
            decoded.append(font[pat])

    return ''.join(decoded)


def main() -> int:
    script_path = Path('/tmp/ff_script.js')
    if not script_path.exists():
        print('missing /tmp/ff_script.js; fetch script.js first', file=sys.stderr)
        return 2

    script_text = script_path.read_text(encoding='utf-8')
    theflag = extract_regex_from_script(script_text)

    marker = '(?=^.{1919}$)'
    if marker not in theflag:
        raise ValueError('marker not found')
    pre, post = theflag.split(marker, 1)

    row_clues = extract_row_clues(post)
    col_clues = extract_column_clues(pre)

    grid = solve_nonogram(row_clues, col_clues)

    # print the solved bitmap
    print(render(grid))

    # print the exact dot/hash string too
    print('\n---')
    for row in grid:
        print(''.join('#' if v else '.' for v in row))

    # decode and print the final flag
    flag = decode_flag_from_grid(grid)
    print('\n--- decoded flag')
    print(flag)

    return 0


if __name__ == '__main__':
    raise SystemExit(main())
```


### Flag 

`lactf{Wh47_d0_y0u_637_wh3n_y0u_cr055_4_r363x_4nd_4_n0n06r4m?_4_r363x06r4m!}`

### Reference

- [Nonogram / Picross - Wikipedia](https://en.wikipedia.org/wiki/Nonogram)
- [Regular expression lookahead / lookbehind (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions/Assertions)
- [Satisfiability Modulo Theories (Wikipedia)](https://en.wikipedia.org/wiki/Satisfiability_modulo_theories)


## Helm Hell

### Intro

Awalnya ini keliatan kayak “cuma Helm chart biasa”: render template → keluar YAML → selesai.  
Tapi ada satu gejala yang bikin curiga: **apa pun input yang dikasih, hasilnya selalu `false`**.

Dan karena ini challenge rev, berarti “false” itu bukan bug… itu *pintu depan* yang disamarkan.

Target kita: bikin Helm render `true`—dan dari sana, flag bakal kebuka dengan sendirinya.

---

### Recon: apa aja isi dist?

Mulai dari zip:

```bash
$ ls -la
total 15904
drwxr-xr-x 4 root root       4096 Feb  7 19:40 .
drwxr-xr-x 7 root root       4096 Feb  7 19:16 ..
drwxr-xr-x 3 root root       4096 Feb  7 19:40 helm-hell
-rw-r--r-- 1 root root     105995 Feb  4 12:30 helm-hell.zip
-rw-r--r-- 1 root root   16162235 Feb  7 19:18 helm.tgz
drwxr-xr-x 2 ctf  docker     4096 Apr 11  2024 linux-amd64
```

Isi zip-nya ringkas banget:

```bash
$ unzip -l helm-hell.zip
Archive:  helm-hell.zip
  Length      Date    Time    Name
---------  ---------- -----   ----
       49  2026-02-04 11:52   helm-hell/Chart.yaml
       10  2026-02-04 11:52   helm-hell/values.yaml
   652276  2026-02-04 11:52   helm-hell/templates/_helpers.tpl
      118  2026-02-04 11:52   helm-hell/templates/output.yaml
---------                     -------
   652453                     4 files
```

Empat file, tapi satu yang “bikin curiga”: `templates/_helpers.tpl` ukurannya 652KB.  
Biasanya itu cuma helper… tapi di sini kelihatan kayak *program* yang nyamar jadi helper.

---

### Ngelirik entrypoint: “hasil” diambil dari helper

File output-nya cuma begini:

```yaml
# helm-hell/templates/output.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: output
data:
  result: {{- include "replicaHandler7951" . | quote }}
```

Artinya **nilai `result` = output dari `include "replicaHandler7951"`**.  
Kalau helper itu nge-print string `"true"`, kita menang.

Sekarang cek default values:

```yaml
# helm-hell/values.yaml
input: ""
```

Kita coba render:

```bash
$ ./linux-amd64/helm version --short
v3.14.4+g81c902a

$ ./linux-amd64/helm template t ./helm-hell --set-string input='' | sed -n '1,40p'
---
# Source: helm-program/templates/output.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: output
data:
  result:"false"
```

Oke, baseline: **kosong = false**. Dan (spoiler) input random juga false.

---

### Ngelirik `_helpers.tpl`: ini bukan helper, ini VM

Kita cari fungsi yang dipanggil output.yaml:

```bash
$ rg -n 'define \"replicaHandler7951\"' helm-hell/templates/_helpers.tpl
12842:{{- define "replicaHandler7951" -}}
```

Dan isi fungsinya (alamat “entrypoint” kita ada di sini):

```gotmpl
{{- define "replicaHandler7951" -}}                      {{/* templates/_helpers.tpl:12842 */}}
{{- $mooringBay7952 := dict                              {{/* state object */}}
      "sea" (dict)                                       {{/* tape/memory */}}
      "helm" 0                                           {{/* pointer */}}
      "cargo" ""                                         {{/* output string */}}
      "provisions" (default "" .Values.input)            {{/* user input */}}
      "logbook" 0                                        {{/* input index */}}
  -}}
{{- include "volumeWorker7940" $mooringBay7952 -}}        {{/* run the “program” */}}
{{- $mooringBay7952.cargo -}}                             {{/* return output */}}
{{- end -}}
```

Nama variabelnya (“sea/helm/cargo/logbook”), tapi polanya jelas:

- `sea` = memory (pakai `dict` dan `set`)
- `helm` = pointer/index (dipakai sebagai key string: `printf "%d" $helm`)
- `provisions` = input string
- `logbook` = posisi baca input
- `cargo` = output (akhirnya jadi `"true"` atau `"false"`)

Dan bagian yang bikin ini berasa “VM”: banyak fungsi bentuknya loop rekursif:

```gotmpl
{{- define "tideInlet200" -}}                             {{/* templates/_helpers.tpl:1 */}}
{{- $controllerStack6830 := printf "%d" $helm -}}
{{- $secretPool6829 := default 0 (index $sea $controllerStack6830) -}}
{{- if ne $secretPool6829 0 -}}                           {{/* while sea[helm] != 0 */}}
  {{- $helm = add $helm 1 -}}
  {{- include "nauticalCurrent198" (dict "sea" $sea "helm" $helm "cargo" $cargo "provisions" $provisions "logbook" $logbook) -}}
  {{- $helm = sub $helm 1 -}}
  {{- include "leagueCurrent199"  (dict "sea" $sea "helm" $helm "cargo" $cargo "provisions" $provisions "logbook" $logbook) -}}
  {{- include "tideInlet200"      (dict "sea" $sea "helm" $helm "cargo" $cargo "provisions" $provisions "logbook" $logbook) -}}
{{- end -}}
{{- end -}}
```

Kalau kamu pernah ngeliat compiler yang “ngubah `while` jadi recursion”, ini persis itu.

Bagian penting berikutnya: **di banyak tempat, program baca input byte-per-byte**:

```gotmpl
{{- if lt $logbook (len $provisions) -}}
  {{- $ch := index $provisions $logbook -}}               {{/* ambil 1 char */}}
  {{- $val := int (printf "%d" $ch) -}}                   {{/* ke int 0..255 */}}
  {{- $_ := set $sea (printf "%d" $helm) $val -}}         {{/* simpan ke memory */}}
  {{- $logbook = add $logbook 1 -}}                       {{/* next */}}
{{- end -}}
```

Ini sinyal paling kuat: **input kita diproses sebagai bytes, dan pasti ada compare di dalam VM itu**.

---

### Inti exploit: “debug print” untuk nyolong expected input

Secara rev, kita punya dua opsi:

1) de-obfuscate seluruh VM (capek), atau  
2) manfaatin fakta bahwa Helm *harus mengeksekusi template* → kita bisa bikin “printf” versi YAML.

Kuncinya: `include` di Helm itu side-effect friendly. Kita bisa:

- nambah template baru (`debug.yaml`) yang memanggil VM yang sama,
- tapi output-nya bukan `true/false`—melainkan string “expected input” yang disiapkan VM saat compare.

Trik praktis yang kepake di challenge ini:

- setiap kali VM mau baca sebuah karakter dari input, ternyata dia juga “mengatur” cell tertentu (cell `0`) ke **byte yang seharusnya**,
- kalau kita ambil nilai cell `0` itu tiap kali input dibaca, kita bisa ngerangkai expected string-nya.

#### Patch otomatis (di folder debug, biar dist asli amam)

Script ini:

- copy chart ke `helm-hell-debug/`
- cari semua blok `index $provisions $logbook` (ada 41 kali)
- setelah tiap blok selesai (`{{- end -}}`), sisipkan kode yang *append* `sea["0"]` ke `.expected_str`
- buat `templates/debug.yaml` untuk nge-print `.expected_str`

```python
#!/usr/bin/env python3
"""
extract_expected.py — patch Helm chart untuk “debug print” expected flag.

Kenapa begini?
- Helm template dieksekusi, jadi kita bisa “mengintip” state VM lewat output YAML.
"""

import shutil
from pathlib import Path

src = Path("helm-hell")
dst = Path("helm-hell-debug")

# 1) Duplikasi chart supaya dist asli gak kotor
shutil.rmtree(dst, ignore_errors=True)
shutil.copytree(src, dst)

helpers = dst / "templates" / "_helpers.tpl"
lines = helpers.read_text().splitlines(True)

needle = "index $provisions $logbook"

# 2) Ini “sniffer”-nya: ambil byte di cell 0, append ke expected_str
snippet = (
    '{{- $_ := set . "expected_str" '
    '(printf "%s%c" (default "" .expected_str) (default 0 (index $sea "0"))) -}}\n'
)

out = []
i = 0
patched = 0

while i < len(lines):
    out.append(lines[i])
    if needle in lines[i]:
        # 3) Loncat sampai end dari blok input-read, lalu sisipkan snippet
        j = i
        while j < len(lines) and lines[j].strip() != "{{- end -}}":
            j += 1
        if j >= len(lines):
            raise SystemExit("end block not found")

        i += 1
        while i <= j:
            out.append(lines[i])
            i += 1

        out.append(snippet)
        patched += 1
        continue
    i += 1

helpers.write_text("".join(out))

# 4) Template debug buat nge-print expected_str
(dst / "templates" / "debug.yaml").write_text(
    "apiVersion: v1\n"
    "kind: ConfigMap\n"
    "metadata:\n"
    "  name: debug\n"
    "data:\n"
    '  expected_str: {{- $st := dict "sea" (dict) "helm" 0 "cargo" "" '
    '"provisions" (default "" .Values.input) "logbook" 0 -}}'
    '{{- include "volumeWorker7940" $st -}}'
    '{{- (default "" $st.expected_str) | quote }}\n'
)

print(f"patched input-read blocks: {patched}")
print("debug chart:", dst)
```

Run:

```bash
$ python3 extract_expected.py
patched input-read blocks: 41
debug chart: helm-hell-debug

$ ./linux-amd64/helm template t ./helm-hell-debug --set-string input='' | sed -n '1,80p'
---
# Source: helm-program/templates/debug.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: debug
data:
  expected_str:"lactf{t4k1ng_7h3_h3lm_0f_h31m_73mp14t3s}\x00"
---
# Source: helm-program/templates/output.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: output
data:
  result:"false"
```

Dapet!! . Tapi ada `\x00` di akhir—itu “null terminator” / padding karena kita ngintip 1 langkah “kelebihan”.  
Jadi expected string yang bener cukup ambil sampai sebelum `\x00`.

---

### Exploit: kasih input yang diminta VM → `true`

Sekarang tinggal supply input itu ke chart asli:

```bash
$ FLAG='lactf{t4k1ng_7h3_h3lm_0f_h31m_73mp14t3s}'
$ ./linux-amd64/helm template t ./helm-hell --set-string input=\"$FLAG\" | sed -n '1,40p'
---
# Source: helm-program/templates/output.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: output
data:
  result:"true"
```

Dan di situlah flag-nya:

> `lactf{t4k1ng_7h3_h3lm_0f_h31m_73mp14t3s}`

---

### Flag

`lactf{t4k1ng_7h3_h3lm_0f_h31m_73mp14t3s}`


### Referensi belajar lanjut

- [Helm Chart Template Guide](https://helm.sh/docs/chart_template_guide/)
- [Go `text/template` (dasar templating yang dipakai Helm)](https://pkg.go.dev/text/template)
- [Brainfuck (biar kebayang konsep tape+pointer yang mirip)](https://esolangs.org/wiki/Brainfuck)


## lactf-1986

### Intro

Ada sesuatu yang satisfying dari challenge jadul: ukurannya kecil, pesannya to-the-point, dan “kuncinya” biasanya cuma satu ide yang dieksekusi rapih.

Di sini kita dapet satu floppy image (`CHALL.IMG`) berisi program DOS `CHALL.EXE` yang ngaku *flag checker*. Goal kita simpel:

> Temuin flag yang bikin program bilang: **“Indeed, that's the flag!”**

Dan ya—kita bakal “ngerusak” checker-nya dengan cara yang elegan: bukan nembak-nebak flag, tapi balikkan algoritmanya.

---

### Recon: bongkar isi floppy

Mulai dari isi folder:

```bash
$ ls -1
CHALL.EXE
```

Cek tipe filenya:

```bash
$ file CHALL.IMG CHALL.EXE
CHALL.IMG: DOS/MBR boot sector, code offset 0x3c+2, OEM-ID "IPRT 6.2", root entries 224, sectors 2880 (volumes <=32 MB), sectors/FAT 9, sectors/track 18, serial number 0x46ba57e0, label: "           ", FAT (12 bit), followed by FAT
CHALL.EXE: MS-DOS executable, MZ for MS-DOS
```

Kita dapat `CHALL.EXE`, dari mount image FAT12-nya:

```bash
# Buat mount point
$ mkdir -p mnt

# Mount read-only sebagai vfat
$ mount -o loop,ro -t vfat CHALL.IMG mnt

# Lihat isinya
$ ls -la mnt
total 21
drwxr-xr-x 2 root root 7168 Jan  1  1970 .
drwxr-xr-x 3 root root 4096 Feb  7 13:33 ..
-r-xr-xr-x 1 root root 9990 Feb  2  1986 CHALL.EXE

# Copy keluar (opsional)
$ cp mnt/CHALL.EXE .

# Unmount
$ umount mnt
```

---

### Ngelirik binary: strings sudah ngasih “map”

Tanpa emulator pun, `strings` langsung kasih alur program:

```bash
$ strings -n 4 CHALL.EXE
...
79:UCLA NetSec presents: LACTF '86 Flag Checker
80:Check your Flag:
81:Sorry, the flag must begin with "lactf{..."
82:Sorry, that's not the flag.
83:Indeed, that's the flag!
...
```

Artinya checker ini:

1. Print banner
2. Minta input
3. Validasi prefix `lactf{`
4. Kalau salah: “not the flag”
5. Kalau bener: “Indeed…”

Yang menarik: size EXE cuma ~10KB. Biasanya ini pertanda algoritmanya ringkas dan bisa kita reverse sampai ketemu “target” yang disembunyikan.

---

### Bonus: vaddr vs file offset (MZ header)

Ini bagian kecil yang sering bikin orang “kepleset”: di `radare2`, kita sering ngomongin “virtual address” / offset in-memory. Tapi untuk ngambil bytes mentah dari file, kita butuh **file offset**.

Di format DOS MZ, ukuran header disimpan di field `e_cparhdr` (jumlah *paragraph* 16-byte). Buat binary ini:

```python
import struct
exe = open("CHALL.EXE","rb").read()
(e_cparhdr,) = struct.unpack_from("<H", exe, 0x08)
print("e_cparhdr =", hex(e_cparhdr), "paragraphs")
print("header_size =", hex(e_cparhdr * 16), "bytes")
```

```bash
e_cparhdr = 0x3 paragraphs
header_size = 0x30 bytes
```

Makanya ciphertext di vaddr `0x24D6` bisa diambil dari file offset `0x24D6 + 0x30 = 0x2506`.

---

### Bedah algoritma: dua blok yang paling penting

Kita pakai `radare2` buat lihat disassembly 16-bit.

#### 1) Ciphertext embedded (alamat yang wajib dicatat)

Ada blob byte yang “nggak kebaca” (bukan string) di:

- **Virtual address (r2):** `0x24D6`
- **Panjang:** `0x49` bytes
- **File offset:** `0x24D6 + 0x30 = 0x2506` (MZ header-nya 0x30 byte)

Dump ciphertext-nya:

```bash
$ r2 -2 -q -A -c 'e scr.color=false; px 0x49 @ 0x24d6' CHALL.EXE
- offset - D6D7 D8D9 DADB DCDD DEDF E0E1 E2E3 E4E5  6789ABCDEF012345
0000:24d6  b68c 958f 9b85 4c5e ecb6 b8c0 9793 0b58  ......L^.......X
0000:24e6  7750 b02c 7e28 7af1 b604 efbe 5c44 78e8  wP.,~(z.....\Dx.
0000:24f6  9981 048f 0340 a73f fab7 0801 6352 e3ad  .....@.?....cR..
0000:2506  d185 9f94 21d5 2a5c 20d4 3112 ceaa 16c7  ....!.*\ .1.....
0000:2516  addf 295d 72fc 2490 2c                   ..)]r.$.,
```

Kalau ini checker klasik, 99% pola-nya adalah:

> input → diolah → hasilnya dibandingkan dengan ciphertext embedded ini

Jadi target kita: balikkan proses “input → ciphertext” jadi “ciphertext → input”.

---

#### 2) Hash 20-bit: “seed” dibuat dari plaintext (fungsi @ `0x0010`)

Bagian ini kuncinya: program bikin sebuah nilai 2z0-bit dari input (seed), lalu seed itu dipakai untuk generate keystream.

Potongan ASM yang paling informatif ada di sekitar `0x0039`:

```bash
$ r2 -2 -q -A -c 'e scr.color=false; pd 28 @ 0x0039' CHALL.EXE
│       ╎   ; DATA XREFS from fcn.00000ca4 @ 0xcc8(r), 0xd12(r)
│       ╎   0000:0039     8b5efc         mov bx, word [var_4h]
│       ╎   0000:003c     89f7           mov di, si
│       ╎   ; DATA XREF from fcn.00002054 @ 0x205c(r)
│       ╎   ; DATA XREF from fcn.000022e9 @ +0x18(r)
│       ╎   0000:003e     b90600         mov cx, 6
│       ╎   ; CODE XREF from fcn.00000010 @ 0x45(x)
│       ╎   ; DATA XREF from fcn.00001a14 @ 0x1a29(x)
│      ┌──> 0000:0041     d1e3           shl bx, 1
│      ╎╎   ; DATA XREF from fcn.00001078 @ 0x112d(r)
│      ╎╎   0000:0043     d1d7           rcl di, 1
│      │╎   ; DATA XREF from fcn.00001078 @ 0x1129(r)
│      └──< 0000:0045     e2fa           loop 0x41
│       ╎   ; DATA XREF from fcn.00001078 @ 0x147c(r)
│       ╎   0000:0047     8b46fc         mov ax, word [var_4h]
│       ╎   ; DATA XREF from fcn.000000b0 @ 0xed(r)
│       ╎   ; DATA XREF from entry0 @ 0x3c4(r)
│       ╎   ; DATA XREF from fcn.00002328 @ 0x2359(r)
│       ╎   0000:004a     89f2           mov dx, si
│       ╎   ; DATA XREF from fcn.000004e1 @ 0x520(r)
│       ╎   ; DATA XREF from fcn.00000ca4 @ 0xd53(r)
│       ╎   0000:004c     d1e0           shl ax, 1
│       ╎   ; DATA XREF from fcn.00000ca4 @ 0xdc3(r)
│       ╎   0000:004e     d1d2           rcl dx, 1
│       ╎   ; DATA XREFS from fcn.000000b0 @ 0xe0(r), 0xe3(w)
│       ╎   ; DATA XREF from fcn.00001078 @ 0x1125(r)
│       ╎   ; DATA XREF from fcn.00002150 @ 0x2168(r)
│       ╎   0000:0050     01d8           add ax, bx
│       ╎   0000:0052     11d7           adc di, dx
│       ╎   0000:0054     8b56fc         mov dx, word [var_4h]
│       ╎   ; DATA XREF from fcn.00000ca4 @ 0xdbf(r)
│       ╎   0000:0057     01c2           add dx, ax
│       ╎   0000:0059     11f7           adc di, si
│       ╎   0000:005b     8a46fe         mov al, byte [var_2h]
│       ╎   0000:005e     30e4           xor ah, ah
│       ╎   0000:0060     31f6           xor si, si
│       ╎   ; DATA XREFS from fcn.00001078 @ 0x10a5(r), 0x146e(r)
│       ╎   0000:0062     01c2           add dx, ax
│       ╎   ; DATA XREFS from fcn.00001078 @ 0x10dc(r), 0x1121(r)
│       ╎   0000:0064     8956fc         mov word [var_4h], dx
│       ╎   ; DATA XREF from fcn.00001078 @ 0x1417(r)
│       ╎   0000:0067     11fe           adc si, di
│       ╎   ; DATA XREFS from fcn.00001078 @ 0x1179(r), 0x1413(r)
│       ╎   0000:0069     83e60f         and si, 0xf
```

Intinya tuh:

- State 20-bit disimpan sebagai:
  - low 16-bit di `[var_4h]`
  - high 4-bit di register `si` (dibatesin `& 0xF`)
- Loop `shl`+`rcl` sebanyak 6 kali itu = **shift-left 6** (alias `x << 6`)
- Lalu ada shift-left 1 (alias `x << 1`)
- Kemudian dijumlahkan dan di-`& 0xF` untuk keep 20-bit
- Terakhir ditambah byte input (`add dx, ax` setelah `ax = input_byte`)

Bisa di sebut itu adalah hash:

```text
hash = (hash * 67 + byte) mod 2^20
```

Kenapa 67? Karena gampang dihitung pakai shift:

- `67 = 64 + 2 + 1`
- `hash*67 = (hash<<6) + (hash<<1) + hash`

---

#### 3) LFSR 20-bit: generator keystream (fungsi @ `0x007B`)

Berikut output `radare2` yang menunjukkan “mesin” keystream-nya (perhatikan `xor`+`and 1`, lalu shift/rotate kanan, lalu inject bit ke nibble atas `dx`):

```bash
$ r2 -2 -q -A -c 'e scr.color=false; pd 24 @ 0x0087' CHALL.EXE | head -n 22
│       ╎   0000:0087     89c3           mov bx, ax
│       ╎   0000:0089     89d6           mov si, dx
│       ╎   0000:008b     b90300         mov cx, 3
│       ╎   ; CODE XREF from fcn.0000007b @ 0x92(x)
│      ┌──> 0000:008e     d1ea           shr dx, 1
│      ╎╎   ; DATA XREF from segment.seg_001 @ +0x18c(r)
│      ╎╎   0000:0090     d1d8           rcr ax, 1
│      └──< 0000:0092     e2fa           loop 0x8e
│       ╎   0000:0094     89c7           mov di, ax
│       ╎   0000:0096     31df           xor di, bx
│       ╎   0000:0098     83e701         and di, 1
│       ╎   0000:009b     89d8           mov ax, bx
│       ╎   0000:009d     89f2           mov dx, si
│       ╎   ; DATA XREF from fcn.000021e7 @ +0x3d(r)
│       ╎   0000:009f     d1ea           shr dx, 1
│       ╎   0000:00a1     d1d8           rcr ax, 1
│       ╎   0000:00a3     b103           mov cl, 3
│       ╎   0000:00a5     89fe           mov si, di
│       ╎   0000:00a7     d3e6           shl si, cl
│       ╎   0000:00a9     09f2           or dx, si
│       ╎   0000:00ab     83e20f         and dx, 0xf
└       └─< 0000:00ae     ebc6           jmp 0x76                      ; fcn.00000010+0x66
```

Cara bacanya (biar gak cuma “percaya doang”):

- `shr dx,1` + `rcr ax,1` di-loop 3x ⇒ `state` digeser kanan 3 bit (`state >> 3`).
- `mov di, ax; xor di, bx; and di, 1` ⇒ ambil LSB dari `(state >> 3) XOR state` ⇒ **bit0 XOR bit3**.
- `shr dx,1; rcr ax,1` sekali lagi ⇒ `state >> 1`.
- `shl si, 3; or dx, si` ⇒ inject `feedback` ke nibble atas `dx` (yang merepresentasikan bit19), lalu `and dx, 0xf` menjaga state tetap 20-bit.

Intinya: ini **LFSR 20-bit** dengan tap **bit 0** dan **bit 3**.

---

### Inti exploit: “ciphertext → plaintext” + cek self-consistency

Sekarang kita punya gambaran algoritma:

```text
cipher = bytes_at(0x24D6, len=0x49)

seed = hash67(flag)                  # 20-bit
state = seed
for i in range(len(flag)):
    state = lfsr_step(state)         # feedback bit0^bit3, shift, inject to bit19
    cipher[i] == flag[i] XOR (state & 0xff)
```

Karena ciphertext embedded dan seed cuma 20-bit:

- space seed = `2^20 = 1,048,576`
- itu **bruteforce-able** dalam hitungan detik

Trik biar cepat:

1. Bruteforce seed
2. Decrypt ciphertext dengan seed tsb
3. Early filter: plaintext harus mulai dengan `lactf{`
4. Validasi final: `hash67(plaintext) == seed` (ini yang bikin “konsisten”)

Begitu ketemu yang konsisten, plaintext itulah flag.

---

### Solver: brute force 2^20 yang “rapih dan masuk akal”

```python
#!/usr/bin/env python3
from __future__ import annotations

from pathlib import Path

# Kita kerja dengan state 20-bit (mask 0xFFFFF)
MASK_20 = (1 << 20) - 1

# File CHALL.EXE ini MZ (DOS). Data yang kita lihat di radare2 pakai "virtual address"
# dan untuk mapping ke file offset, kita perlu tambah ukuran header MZ (0x30).
HEADER_SIZE = 0x30

# Ciphertext embedded ada di vaddr 0x24D6, panjang 0x49 bytes.
VADDR_CIPHERTEXT = 0x24D6
CIPHERTEXT_LEN = 0x49

# Kita punya known prefix dari output program: "flag harus begin dengan lactf{"
PREFIX = b"lactf{"


def lfsr_step(state: int) -> int:
    """
    LFSR 20-bit dari ASM:
      feedback = (bit0 XOR bit3)
      state = (state >> 1) | (feedback << 19)
    """
    feedback = (state ^ (state >> 3)) & 1
    return ((state >> 1) | (feedback << 19)) & MASK_20


def hash67(data: bytes) -> int:
    """
    Hash 20-bit dari ASM @ 0x0010:
      h = (h * 67 + b) mod 2^20
    """
    h = 0
    for b in data:
        h = (h * 67 + b) & MASK_20
    return h


def decrypt(cipher: bytes, seed: int) -> bytes:
    """
    Decrypt ciphertext dengan seed:
      state = seed
      for each byte:
        state = lfsr_step(state)
        plaintext_byte = cipher_byte XOR (state & 0xFF)
    """
    state = seed
    out = bytearray(len(cipher))
    for i, cb in enumerate(cipher):
        state = lfsr_step(state)
        out[i] = cb ^ (state & 0xFF)
    return bytes(out)


def main() -> None:
    exe = Path("CHALL.EXE").read_bytes()

    # Ambil ciphertext langsung dari file (vaddr -> file offset)
    start = VADDR_CIPHERTEXT + HEADER_SIZE
    cipher = exe[start : start + CIPHERTEXT_LEN]
    if len(cipher) != CIPHERTEXT_LEN:
        raise SystemExit("failed to extract ciphertext")

    # Bruteforce semua seed 20-bit
    for seed in range(1 << 20):
        # Early prune: cek prefix dulu biar cepat
        if decrypt(cipher[: len(PREFIX)], seed) != PREFIX:
            continue

        pt = decrypt(cipher, seed)

        # Sanity checks: jangan ada NUL, dan mayoritas printable
        if 0 in pt:
            continue
        if any(c < 0x20 or c > 0x7E for c in pt):
            continue

        # Self-consistency check: seed harus sama dengan hash67(plaintext)
        if hash67(pt) != seed:
            continue

        print(pt.decode())
        return

    raise SystemExit("no solution found")


if __name__ == "__main__":
    main()
```

Jalankan solver:

```bash
$ python3 solve.py
lactf{3asy_3nough_7o_8rute_f0rce_bu7_n0t_ea5y_en0ugh_jus7_t0_brut3_forc3}
```

### Referensi belajar lanjut

- [Linear-feedback shift register (LFSR) — Wikipedia](https://en.wikipedia.org/wiki/Linear-feedback_shift_register)
- [MS-DOS MZ executable format (overview)](https://en.wikipedia.org/wiki/DOS_MZ_executable)


## Starless C

### Intro

“The son of the fortune-teller stands before three doors. A bee. A key. A flag.”

Kalimat pembuka challenge ini kerasa puitis… tapi binarinya justru kebalikannya: **gimmick** yang rapi, tajam, dan *sangat* ELF-nerdy. Programnya bilang “ada flag di binary”, tapi kalau dijalankan normal, kita cuma dikasih narasi “Not yet.” dan selesai.

Twist-nya: ini bukan soal *bruteforce input* atau decompile panjang. Ini soal **ngeliat ELF sebagai puzzle box**, terutama bagian yang sering diabaikan: **program header (PT\_LOAD)**.

Target akhir kita sederhana:

- nemuin gimana “tiga pintu” itu bekerja,
- ngebuka jalan sampai eksekusi “flag printer”,
- kirim urutan input yang bener ke remote, dan ambil flag.

---

### Recon: apa aja isi dist?

Mulai dari artifacts:

```bash
$ ls -la
starless_c
```

Lihat formatnya:

```bash
$ file starless_c
starless_c: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, no section header
```

**No section header** itu langsung jadi petunjuk: tools yang biasa mengandalkan section (`.text`, `.rodata`, simbol, dst) bakal “buta”. Tapi loader Linux *gak peduli section* — yang dipakai runtime itu **program header**.

Kalau dijalankan:

```bash
$ ./starless_c </dev/null
There is a flag in the binary.
  (The flag is a metaphor but also still a flag.)
  (The binary could rightly be considered a gimmick.)
And so the son of the fortune-teller does not find his way to the Starless C. Not yet.
```

Oke. Jadi “jalannya belum ketemu”, berarti ada mekanisme gate/maze.

---

### Ngelirik ELF header: entrypoint yang “nggak wajar”

Sekarang kita cek header ELF:

```bash
$ readelf -h starless_c | sed -n '1,30p'
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 03 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - GNU
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x13370000
  Start of program headers:          64 (bytes into file)
  Start of section headers:          0 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         58
  Size of section headers:           0 (bytes)
  Number of section headers:         0
  Section header string table index: 0
```

Entry point `0x13370000` itu *nggak* normal untuk binary biasa—ini udah kebaca sebagai “program yang sengaja dipetakan ke alamat-alamat absurd”.

---

### Ngelirik program header: program header jadi “papan catur”

Karena section header hilang, langkah enak adalah: ambil semua segmen `PT_LOAD` yang executable dari program header, lalu lihat *alamat virtual* dan *offset file*.

Berikut script kecil yang aku pakai:

```python
#!/usr/bin/env python3
# Extract executable PT_LOAD segments (page-sized) from ELF program headers.

import struct
from pathlib import Path

data = Path("starless_c").read_bytes()

# ELF64 little-endian: e_phoff @ 0x20, e_phentsize @ 0x36, e_phnum @ 0x38
e_phoff = struct.unpack_from("<Q", data, 0x20)[0]
e_phentsz = struct.unpack_from("<H", data, 0x36)[0]
e_phnum = struct.unpack_from("<H", data, 0x38)[0]

print("phoff", hex(e_phoff), "phentsz", e_phentsz, "phnum", e_phnum)

PT_LOAD = 1
for i in range(e_phnum):
    ph = e_phoff + i * e_phentsz
    p_type, p_flags = struct.unpack_from("<II", data, ph)
    p_offset, p_vaddr, _, p_filesz, _, p_align = struct.unpack_from("<QQQQQQ", data, ph + 8)

    # Only keep executable, page-sized PT_LOAD segments.
    if p_type == PT_LOAD and p_filesz == 0x1000 and (p_flags & 0x1):
        head = data[p_offset : p_offset + 8].hex()
        print(
            f"vaddr={p_vaddr:#x} off={p_offset:#x} flags={p_flags:#x} "
            f"align={p_align:#x} head={head}"
        )
```

Output-nya yan relevan:

```text
phoff 0x40 phentsz 56 phnum 58
vaddr=0x13370000 off=0x9000 flags=0x5 align=0x1f756dd2c8ac64a7 head=48b86d69636b2e29
vaddr=0x42069000 off=0x6000 flags=0x5 align=0xa0cc45069a13e2e7 head=48b86520666c6167
vaddr=0x67679000 off=0x10000 flags=0x7 align=0x3f7164456744f0b0 head=31c0880031c08800
vaddr=0x6767a000 off=0x18000 flags=0x7 align=0xd56a9cc98308210a head=31c08800e9f77f00
...
vaddr=0x6768a000 off=0x3000 flags=0x7 align=0xe73dd8a09b15d827 head=90909090e9f76f00
...
vaddr=0x67692000 off=0x1000 flags=0x7 align=0xa9eed768556fc6b9 head=31c08800e9f76f9d
```

Ada dua hal yang langsung “connect”:

1. Ada segmen executable di `0x42069000` — ini kelihatan seperti *payload lain*.
2. Banyak segmen executable di range `0x6767xxxx` — ini terlihat seperti **grid/maze per halaman** (masing-masing 0x1000).

Dan pattern `head` menarik:

- `31 c0 88 00` = `xor eax,eax; mov [rax],al` → *write ke NULL* → sengaja segfault.
- `90 90 90 90 e9 ...` = **NOP sled + JMP** → ini “pintu yang kebuka”.

Kita cek mana “pintu kebuka” dari awal (byte pertama = `0x90`):

```python
import struct
from pathlib import Path
data = Path("starless_c").read_bytes()

e_phoff = struct.unpack_from("<Q", data, 0x20)[0]
e_phentsz = struct.unpack_from("<H", data, 0x36)[0]
e_phnum = struct.unpack_from("<H", data, 0x38)[0]

PT_LOAD = 1
pages = []
for i in range(e_phnum):
    ph = e_phoff + i * e_phentsz
    p_type, p_flags = struct.unpack_from("<II", data, ph)
    p_offset, p_vaddr, _, p_filesz, _, _ = struct.unpack_from("<QQQQQQ", data, ph + 8)
    if p_type == PT_LOAD and p_filesz == 0x1000 and (p_flags & 0x1) and (0x67600000 <= p_vaddr < 0x67700000):
        pages.append((p_vaddr, p_offset))

pages.sort()
nops = [hex(v) for v, off in pages if data[off] == 0x90]
print("maze pages:", len(pages))
print("NOP-start pages:", len(nops))
print("\\n".join(nops))

#output:

maze pages: 23
NOP-start pages: 5
0x67689000
0x6768a000
0x6768c000
0x6768d000
0x67694000
```

Jadi awalnya cuma 5 halaman yang “aman” (pintu kebuka). Yang lain… kalau dieksekusi dari awal halaman, bakal segfault.

---

### Bonus: dua dunia eksekusi (handler vs maze)

#### 1) Entry point: pasang SIGSEGV handler, lalu lompat ke maze

Kalau kita disassemble entry `0x13370000` (pakai `ndisasm` karena `objdump` juga rewel di ELF ini), kita lihat pola “syscall-only”:

```bash
$ dd if=starless_c bs=1 skip=$((0x9000)) count=$((0x120)) status=none | ndisasm -b64 -o0x13370000 - | sed -n '45,65p'
133700BB  B801000000        mov eax,0x1
133700C0  BF01000000        mov edi,0x1
133700C5  4889E6            mov rsi,rsp
133700C8  BA87000000        mov edx,0x87
133700CD  0F05              syscall
133700CF  4883EC20          sub rsp,0x20
133700D3  48C7C003013713    mov rax,0x13370103
133700DA  48890424          mov [rsp],rax
133700DE  C644240B04        mov byte [rsp+0xb],0x4
```

Bagian pentingnya:

- dia **print** intro (syscall `write`),
- lalu **set handler SIGSEGV** ke alamat `0x13370103`,
- kemudian lompat ke world kedua: maze di `0x6767900c`.

Itulah kenapa kalau kita salah jalan dan segfault: bukannya crash biasa, program justru “menutup buku” dengan narasi “Not yet.” (itu handler-nya).

#### 2) Maze page: baca input 1 byte, w/a/s/d untuk move, f untuk “final”

Satu halaman maze (contoh: `0x67679000`) bentuknya konsisten. Ini potongan paling penting:

```bash
$ dd if=starless_c bs=1 skip=$((0x10000)) count=$((0x100)) status=none | ndisasm -b64 -o0x67679000 - | sed -n '9,55p'
6767900C  31C0              xor eax,eax
6767900E  31FF              xor edi,edi
67679010  4889E6            mov rsi,rsp
67679013  BA01000000        mov edx,0x1
67679018  0F05              syscall
6767901A  8A06              mov al,[rsi]
6767901C  3C0A              cmp al,0xa
6767901E  74EC              jz 0x6767900c
67679020  3C77              cmp al,0x77
67679022  7418              jz 0x6767903c
...
67679030  3C66              cmp al,0x66
67679032  0F8480000000      jz 0x676790b8
```

Ini loop “read 1 byte”, lalu compare:

- `'w'` → blok movement W
- `'s'` → blok movement S
- `'a'` → blok movement A
- `'d'` → blok movement D
- `'f'` → special jump (final)
- selain itu → *crash* (tulis ke NULL lagi)

Nah, blok movement-nya yang bikin challenge ini unik. Contoh untuk `'s'`:

```text
6767905B  mov eax, [0x67681000]         ; baca 4 byte dari halaman target
67679061  cmp al, 0x90                  ; byte pertama == NOP?
67679065  mov dword [0x67681000], 0x88c031  ; kalau iya: matiin pintu (jadi crash stub)
6767906F  mov [0x67689000], eax         ; pindahin “NOP token” ke lokasi lain
67679075  jmp 0x6768100c                ; masuk halaman target via +0x0c (aman)
```

Dan untuk `'f'`:

```text
676790B8  jmp 0x6767a000
```

Key insight di sini:

- Program **tidak** masuk ke halaman target lewat alamat base (`0x67681000`), tapi lewat `+0x0c` (`0x6768100c`).
  - Itu artinya, walaupun awal halaman berisi instruksi segfault, kita tetap bisa “berjalan” karena entry maze selalu lewat offset aman.
- Tetapi `'f'` **lompat ke base** `0x6767a000` (tanpa `+0x0c`).
  - Jadi `'f'` itu semacam “coba jalankan rangkaian pintu dari awal halaman”.

Dengan kata lain: kita bebas keliling maze, tapi untuk “keluar”, kita butuh beberapa halaman tertentu punya byte awal `0x90` (NOP), supaya base-nya bisa dieksekusi tanpa segfault.

---

### Door mechanism: “NOP token” yang dipindah-pindahin

Kalau kita sederhanakan logic per-move:

- `eax = *(uint32_t*)target`
- kalau `target[0] == 0x90`:
  - `*(uint32_t*)target = 0x0088c031` (ubah jadi crash stub)
  - `*(uint32_t*)store = eax` (copy dword lama—biasanya `0x90909090`—ke tempat lain)
- lalu `jmp target + 0x0c`

Artinya kita punya satu “token” berupa `0x90909090` yang bisa **dipindahkan** dari satu halaman ke halaman lain lewat field `store`.

Jadi ini bukan maze biasa; ini maze yang *stateful*: kita harus menyusun state “halaman mana yang sekarang diawali NOP”.

---

### Bonus: ngebentuk “rantai base jump” sampai flag printer

Ada satu segmen executable lain: `0x42069000`. Kalau kita intip, dia print narasi + `open("flag.txt")` + `sendfile`-like syscall:

```bash
$ dd if=starless_c bs=1 skip=$((0x6000)) count=$((0x100)) status=none | ndisasm -b64 -o0x42069000 - | head -n 25
42069000  mov rax,0xa2e67616c662065
4206900A  push rax
...
42069148  push qword 0x0
4206914A  mov rax,0x7478742e67616c66   ; \"flag.txt\"
42069154  push rax
42069155  mov eax,0x2                  ; sys_open
...
```

String `flag.txt` juga memang ada:

```bash
$ strings -n 4 starless_c | rg -n "flag\\.txt" | head
40:flag.txtP
```

Dan yang paling “terang-terangan”: halaman `0x67692000` punya base jump langsung ke `0x42069000`:

```bash
$ dd if=starless_c bs=1 skip=$((0x1000)) count=$((0x20)) status=none | ndisasm -b64 -o0x67692000 -
67692000  xor eax,eax
67692002  mov [rax],al
67692004  jmp 0x42069000
```

**Masalahnya**: `0x67692000` default-nya diawali crash stub, jadi base jump itu cuma bisa dipakai kalau kita berhasil bikin awal halaman jadi NOP.

Setelah dianalisis, rantai base-jump yang kita butuhkan adalah:

```text
0x6767a000 -> 0x67682000 -> 0x6768a000 -> 0x67691000 -> 0x67692000 -> 0x42069000
```

Jadi goal state-nya:

- halaman-halaman di atas harus punya byte awal `0x90` (NOP),
- lalu tekan `'f'` → program “meluncur” lewat rantai jump → masuk flag printer.

---

### Inti exploit: cari satu-satunya urutan input yang bikin state “benar”

Kita bisa saja manual, tapi ini state-space problem:

- posisi kita = salah satu dari 23 node,
- state token NOP = subset node yang “awal halamannya NOP”.

Jadi aku modelkan sebagai BFS di state `(pos, nop_bitset)`:

- **pos** berubah tiap input (w/a/s/d),
- **nop_bitset** berubah kalau target yang kita masuki dia NOP (token dipindah ke alamat `store`).

Goal: setelah beberapa langkah, `nop_bitset` mencakup:

- `0x6767a000`
- `0x67682000`
- `0x6768a000`
- `0x67691000`
- `0x67692000`

Solver:

1) parse program header,
2) build graph move dari RIP-relative operands,
3) BFS sampai goal state,
4) print input sequence + `'f'`,
5) (opsional) connect ke remote dan ambil flag.

```python
#!/usr/bin/env python3
# Solve LA CTF rev/starless-c:
# - Parse ELF PT_LOAD executable pages (maze)
# - Decode movement edges (w/a/s/d) from RIP-relative addressing
# - Model the “NOP token transfer” as state transitions
# - BFS until the required base pages become NOP, then send 'f'

from __future__ import annotations

import socket
import struct
from collections import deque
from pathlib import Path


def parse_maze_pages(path: str) -> list[tuple[int, int, bytes]]:
    """Return list of (vaddr, file_offset, page_bytes) for maze pages."""
    data = Path(path).read_bytes()

    e_phoff = struct.unpack_from("<Q", data, 0x20)[0]
    e_phentsz = struct.unpack_from("<H", data, 0x36)[0]
    e_phnum = struct.unpack_from("<H", data, 0x38)[0]

    PT_LOAD = 1
    pages: list[tuple[int, int, bytes]] = []

    for i in range(e_phnum):
        ph = e_phoff + i * e_phentsz
        p_type, p_flags = struct.unpack_from("<II", data, ph)
        p_offset, p_vaddr, _, p_filesz, _, _ = struct.unpack_from("<QQQQQQ", data, ph + 8)

        # Maze lives in 0x6760_0000..0x6770_0000 and is page-sized + executable.
        if (
            p_type == PT_LOAD
            and p_filesz == 0x1000
            and (p_flags & 0x1)
            and (0x67600000 <= p_vaddr < 0x67700000)
        ):
            page = data[p_offset : p_offset + 0x1000]
            pages.append((p_vaddr, p_offset, page))

    pages.sort(key=lambda t: t[0])
    return pages


def rip_target(base: int, page: bytes, insn_off: int) -> int:
    """
    Decode RIP-relative target for:
      8B 05 <disp32>  == mov eax, [rip+disp32]
      89 05 <disp32>  == mov [rip+disp32], eax

    Both are 6 bytes long, so next RIP = base + insn_off + 6.
    """
    disp = struct.unpack_from("<i", page, insn_off + 2)[0]
    return base + insn_off + 6 + disp


def build_moves(pages: list[tuple[int, int, bytes]]) -> tuple[list[int], dict[int, dict[str, tuple[int, int | None]]], int]:
    """
    Build move table:
      moves[pos_i][ch] = (tgt_i, store_i_or_None)
    and return (addr_list, moves, init_nops_bitset).
    """
    addr = [v for v, _, _ in pages]
    index = {v: i for i, v in enumerate(addr)}
    mem = [page for _, _, page in pages]

    # Per-node block layout (same across pages):
    #   target read at these offsets
    #   store write at these offsets
    BLOCKS = {
        "w": (0x3C, 0x50),
        "s": (0x5B, 0x6F),
        "a": (0x7A, 0x8E),
        "d": (0x99, 0xAD),
    }

    moves: dict[int, dict[str, tuple[int, int | None]]] = {}
    for pos_i, base in enumerate(addr):
        page = mem[pos_i]
        moves[pos_i] = {}
        for ch, (read_off, store_off) in BLOCKS.items():
            tgt = rip_target(base, page, read_off)
            store = rip_target(base, page, store_off)
            if tgt not in index:
                continue  # not a valid maze node
            moves[pos_i][ch] = (index[tgt], index.get(store))

    init_nops = 0
    for i, page in enumerate(mem):
        if page[0] == 0x90:
            init_nops |= 1 << i

    return addr, moves, init_nops


def solve_sequence(addr: list[int], moves: dict[int, dict[str, tuple[int, int | None]]], init_nops: int) -> str:
    """
    BFS over state (pos_i, nop_bitset).

    Transition rule:
      - You always move to tgt.
      - If tgt is currently NOP-start:
          transfer NOP token from tgt -> store (tgt loses NOP, store gains NOP)
        (and if store is None, that move would crash in real binary, so we skip it)
    """

    start_pos = addr.index(0x67679000)
    start = (start_pos, init_nops)

    required = [
        0x6767A000,
        0x67682000,
        0x6768A000,
        0x67691000,
        0x67692000,
    ]
    req_mask = 0
    for a in required:
        req_mask |= 1 << addr.index(a)

    def is_nop(bitset: int, i: int) -> bool:
        return ((bitset >> i) & 1) == 1

    q = deque([start])
    prev: dict[tuple[int, int], tuple[tuple[int, int], str] | None] = {start: None}

    goal: tuple[int, int] | None = None
    while q:
        pos, nops = q.popleft()
        if (nops & req_mask) == req_mask:
            goal = (pos, nops)
            break

        for ch, (tgt, store) in moves[pos].items():
            n2 = nops

            # Entering a NOP-start page triggers token transfer.
            if is_nop(n2, tgt):
                if store is None:
                    continue
                n2 &= ~(1 << tgt)
                n2 |= 1 << store

            st = (tgt, n2)
            if st not in prev:
                prev[st] = ((pos, nops), ch)
                q.append(st)

    if goal is None:
        raise RuntimeError("No solution found")

    # Reconstruct sequence.
    path: list[str] = []
    cur = goal
    while prev[cur] is not None:
        prev_state, ch = prev[cur]
        path.append(ch)
        cur = prev_state
    return "".join(reversed(path))


def main() -> None:
    pages = parse_maze_pages("starless_c")
    addr, moves, init_nops = build_moves(pages)

    seq = solve_sequence(addr, moves, init_nops)
    payload = (seq + "f\n").encode()

    print("[+] sequence length:", len(seq))
    print("[+] sequence:", seq)
    print("[+] send:", (seq + "f"))

    # Optional: grab remote flag
    host, port = "chall.lac.tf", 32223
    with socket.create_connection((host, port), timeout=5) as s:
        s.sendall(payload)
        s.settimeout(2)
        out = b""
        try:
            while True:
                chunk = s.recv(4096)
                if not chunk:
                    break
                out += chunk
                if b"lactf{" in out:
                    break
        except Exception:
            pass
        print(out.decode(errors="replace"))


if __name__ == "__main__":
    main()
```

Atau kita bisa gunakan “input-nya aja” untuk `nc`, sequence final yang ketemu adalah:

```text
sddddswaasdwaaasdssawwdwddsawasassdddwsddwasaaaawwdwdddsawaasassdddwwdwasssaaawwdwwassdddssddwasaaawwddwdsaaawdsassddwsddwawaawasdddssawdwaaddwaa
```

Lalu tambahin `f` di akhir.

---

### Eksekusi ke remote: ambil flag

Cara paling simpel: `nc`, paste sequence + `f`.

```bash
$ nc chall.lac.tf 32223
There is a flag in the binary.
  (The flag is a metaphor but also still a flag.)
  (The binary could rightly be considered a gimmick.)
A person this far into a challenge has their path to follow. ...
lactf{starless_c_more_like_starless_0xcc}
```


### Flag

`lactf{starless_c_more_like_starless_0xcc}`



## The Three SAT Problem

### Intro

Satu binary, satu pertanyaan sok filosofis:

> “Have you solved the Three-Sat Problem?”

Kek *three body problem theory* right?, yang penting bukan “benar secara akademik”, tapi **bikin programnya percaya** kita benar. Di challenge ini, “Three-Sat” bukan dibikin jadi input CNF yang bisa kita kasih ke solver eksternal, tapi disembunyikan sebagai **boolean circuit raksasa** di assembly.

Target kita: temukan input 1279-bit (string `'0'/'1'`) yang bikin program lewat validasi, lalu program sendiri yang nge-print flag.


---

### Recon: apa aja isi dist?

Di folder challenge ini:

```bash
$ ls -la
total 104
drwxr-xr-x 3 root root  4096 Feb  7 14:00 .
drwxr-xr-x 4 root root  4096 Feb  7 13:48 ..
-rwxr-xr-x 1 root root 84144 Feb  2 06:12 three_sat_problem
```


---

### Ngelirik binary: ELF, stripped, PIE

```bash
$ file three_sat_problem
three_sat_problem: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=2105e69189dfbce45f029e9b3e147b68f0475869, for GNU/Linux 3.2.0, stripped
```

Catatan penting buat pembaca yang baru belajar:
- **PIE** berarti alamat runtime = `base_address + offset`. Tapi `objdump` ngasih kita offset/virtual address dalam ELF (mis. `0x1090`, `0x1289`), dan itu cukup buat analisis statik.
- **stripped** artinya minim simbol; kita ngandelin string, pola kode, dan flow.

---

### Ngelirik runtime: inputnya apa?

Kalau dijalanin tanpa input yang bener, langsung ngegas:

```bash
$ printf '\n' | ./three_sat_problem
Have you solved the Three-Sat Problem?
Please be serious...
```

Jadi ada validasi input yang ketat.

---

### Bonus: string suksesnya ada, jalurnya disembunyiin

`strings` ngasih spoiler yang cukup jelas:

```bash
$ strings -a three_sat_problem | rg -n 'Have you solved|Please be serious|Incredible|I see you'
317:Have you solved the Three-Sat Problem?
318:Please be serious...
319:I see you haven't.
320:Incredible! Let me get the flag for you...
```

Berarti program **pasti punya** cabang sukses (print flag), tinggal kita cariin cara masuknya.

---

### Inti exploit: “SAT”-nya itu boolean circuit di ASM

Kalau kita buka `main`, kelihatan jelas format input + dua syarat kemenangan:

1) input harus panjang **0x4ff = 1279** karakter  
2) tiap karakter harus `'0'` atau `'1'`  
3) fungsi check besar di `0x1289` harus return `AL != 0`  
4) plus satu constraint ekstra: byte di `0x15352` harus bit LSB = 1 (artinya karakter `'1'`)

Output `objdump` bagian krusialnya begini:

```bash
$ objdump -d -Mintel --start-address=0x1099 --stop-address=0x1135 three_sat_problem

three_sat_problem:     file format elf64-x86-64


Disassembly of section .text:

0000000000001099 <.text+0x9>:
    1099:	48 8d 1d c0 3f 01 00 	lea    rbx,[rip+0x13fc0]        # 15060 <stdin@GLIBC_2.2.5+0x10>
    10a0:	48 83 ec 38          	sub    rsp,0x38
    10a4:	e8 87 ff ff ff       	call   1030 <puts@plt>
    10a9:	48 8b 3d 90 3f 01 00 	mov    rdi,QWORD PTR [rip+0x13f90]        # 15040 <stdout@GLIBC_2.2.5>
    10b0:	e8 bb ff ff ff       	call   1070 <fflush@plt>
    10b5:	48 8b 15 94 3f 01 00 	mov    rdx,QWORD PTR [rip+0x13f94]        # 15050 <stdin@GLIBC_2.2.5>
    10bc:	be 00 05 00 00       	mov    esi,0x500
    10c1:	48 89 df             	mov    rdi,rbx
    10c4:	e8 97 ff ff ff       	call   1060 <fgets@plt>
    10c9:	48 89 df             	mov    rdi,rbx
    10cc:	48 8d 35 58 1f 01 00 	lea    rsi,[rip+0x11f58]        # 1302b <__cxa_finalize@plt+0x11fab>
    10d3:	e8 78 ff ff ff       	call   1050 <strcspn@plt>
    10d8:	48 89 df             	mov    rdi,rbx
    10db:	c6 04 03 00          	mov    BYTE PTR [rbx+rax*1],0x0
    10df:	e8 5c ff ff ff       	call   1040 <strlen@plt>
    10e4:	48 3d ff 04 00 00    	cmp    rax,0x4ff
    10ea:	74 09                	je     10f5 <__cxa_finalize@plt+0x75>
    10ec:	48 8d 3d 3a 1f 01 00 	lea    rdi,[rip+0x11f3a]        # 1302d <__cxa_finalize@plt+0x11fad>
    10f3:	eb 36                	jmp    112b <__cxa_finalize@plt+0xab>
    10f5:	48 8d 93 ff 04 00 00 	lea    rdx,[rbx+0x4ff]
    10fc:	48 89 dd             	mov    rbp,rbx
    10ff:	8a 03                	mov    al,BYTE PTR [rbx]
    1101:	83 e8 30             	sub    eax,0x30
    1104:	3c 01                	cmp    al,0x1
    1106:	77 e4                	ja     10ec <__cxa_finalize@plt+0x6c>
    1108:	48 ff c3             	inc    rbx
    110b:	48 39 da             	cmp    rdx,rbx
    110e:	75 ef                	jne    10ff <__cxa_finalize@plt+0x7f>
    1110:	31 c0                	xor    eax,eax
    1112:	e8 72 01 00 00       	call   1289 <__cxa_finalize@plt+0x209>
    1117:	84 c0                	test   al,al
    1119:	74 09                	je     1124 <__cxa_finalize@plt+0xa4>
    111b:	f6 05 30 42 01 00 01 	test   BYTE PTR [rip+0x14230],0x1        # 15352 <stdin@GLIBC_2.2.5+0x302>
    1122:	75 11                	jne    1135 <__cxa_finalize@plt+0xb5>
    1124:	48 8d 3d 17 1f 01 00 	lea    rdi,[rip+0x11f17]        # 13042 <__cxa_finalize@plt+0x11fc2>
    112b:	e8 00 ff ff ff       	call   1030 <puts@plt>
    1130:	6a 01                	push   0x1
    1132:	58                   	pop    rax
    1133:	eb 5e                	jmp    1193 <__cxa_finalize@plt+0x113>
```

Kalau check-nya lolos, `main` nge-pack 320 bit menjadi 40 byte string, pakai tabel indeks di `0x13080`:

```bash
$ objdump -d -Mintel --start-address=0x1135 --stop-address=0x119a three_sat_problem

three_sat_problem:     file format elf64-x86-64


Disassembly of section .text:

0000000000001135 <.text+0xa5>:
    1135:	48 8d 3d 19 1f 01 00 	lea    rdi,[rip+0x11f19]        # 13055 <__cxa_finalize@plt+0x11fd5>
    113c:	e8 ef fe ff ff       	call   1030 <puts@plt>
    1141:	0f 57 c0             	xorps  xmm0,xmm0
    1144:	48 8d 7c 24 17       	lea    rdi,[rsp+0x17]
    1149:	31 c0                	xor    eax,eax
    114b:	0f 11 44 24 07       	movups XMMWORD PTR [rsp+0x7],xmm0
    1150:	6a 19                	push   0x19
    1152:	59                   	pop    rcx
    1153:	f3 aa                	rep stos BYTE PTR [rdi],al
    1155:	31 c0                	xor    eax,eax
    1157:	48 8d 3d 22 1f 01 00 	lea    rdi,[rip+0x11f22]        # 13080 <__cxa_finalize@plt+0x12000>
    115e:	48 63 14 87          	movsxd rdx,DWORD PTR [rdi+rax*4]
    1162:	89 c6                	mov    esi,eax
    1164:	89 c1                	mov    ecx,eax
    1166:	48 ff c0             	inc    rax
    1169:	c1 fe 03             	sar    esi,0x3
    116c:	83 e1 07             	and    ecx,0x7
    116f:	8a 54 15 00          	mov    dl,BYTE PTR [rbp+rdx*1+0x0]
    1173:	48 63 f6             	movsxd rsi,esi
    1176:	83 e2 01             	and    edx,0x1
    1179:	d3 e2                	shl    edx,cl
    117b:	08 54 34 07          	or     BYTE PTR [rsp+rsi*1+0x7],dl
    117f:	48 3d 40 01 00 00    	cmp    rax,0x140
    1185:	75 d7                	jne    115e <__cxa_finalize@plt+0xde>
    1187:	48 8d 7c 24 07       	lea    rdi,[rsp+0x7]
    118c:	e8 9f fe ff ff       	call   1030 <puts@plt>
    1191:	31 c0                	xor    eax,eax
    1193:	48 83 c4 38          	add    rsp,0x38
    1197:	5b                   	pop    rbx
    1198:	5d                   	pop    rbp
    1199:	c3                   	ret
```

Ada dua “petunjuk emas” dari potongan ini:

- Input buffer ada di **`0x15060`** (`lea rbx, [rip+...] # 15060`)
- Check function besar dipanggil di **`call 1289`**
- Constraint ekstra: `test BYTE PTR [rip+...],0x1 # 15352`

Karena base input = `0x15060`, alamat `0x15352` itu sama dengan:

```
0x15352 - 0x15060 = 0x2f2
```

Jadi program literally minta: `input[0x2f2]` harus `'1'` (karena `'0' & 1 = 0`, `'1' & 1 = 1`).

---

### Bonus: check function-nya branchless

Kalau kita intip awal fungsi check (`0x1289`), polanya repetitif:
- baca byte input dari RIP-relative (alamat di range `0x15060..0x1555e`)
- `not` (negasi)
- kadang `and eax, 1` (ambil bit LSB)
- simpan ke stack temp (`[rsp+...]`)

```bash
$ objdump -d -Mintel --start-address=0x1289 --stop-address=0x1320 three_sat_problem

three_sat_problem:     file format elf64-x86-64


Disassembly of section .text:

0000000000001289 <.text+0x1f9>:
    1289:	41 57                	push   r15
    128b:	41 56                	push   r14
    128d:	41 55                	push   r13
    128f:	41 54                	push   r12
    1291:	55                   	push   rbp
    1292:	53                   	push   rbx
    1293:	48 81 ec c0 03 00 00 	sub    rsp,0x3c0
    129a:	8a 05 c0 3d 01 00    	mov    al,BYTE PTR [rip+0x13dc0]        # 15060 <stdin@GLIBC_2.2.5+0x10>
    12a0:	f7 d0                	not    eax
    12a2:	83 e0 01             	and    eax,0x1
    12a5:	88 44 24 91          	mov    BYTE PTR [rsp-0x6f],al
    12a9:	8a 05 ac 42 01 00    	mov    al,BYTE PTR [rip+0x142ac]        # 1555b <stdin@GLIBC_2.2.5+0x50b>
    12af:	f7 d0                	not    eax
    12b1:	83 e0 01             	and    eax,0x1
    12b4:	88 44 24 b6          	mov    BYTE PTR [rsp-0x4a],al
    12b8:	8a 05 e8 3d 01 00    	mov    al,BYTE PTR [rip+0x13de8]        # 150a6 <stdin@GLIBC_2.2.5+0x56>
    12be:	f7 d0                	not    eax
    12c0:	88 44 24 fa          	mov    BYTE PTR [rsp-0x6],al
    12c4:	8a 05 a8 3e 01 00    	mov    al,BYTE PTR [rip+0x13ea8]        # 15172 <stdin@GLIBC_2.2.5+0x122>
    12ca:	f7 d0                	not    eax
    12cc:	83 e0 01             	and    eax,0x1
    12cf:	88 84 24 5d 02 00 00 	mov    BYTE PTR [rsp+0x25d],al
    12d6:	8a 05 45 40 01 00    	mov    al,BYTE PTR [rip+0x14045]        # 15321 <stdin@GLIBC_2.2.5+0x2d1>
    12dc:	f7 d0                	not    eax
    12de:	88 44 24 fb          	mov    BYTE PTR [rsp-0x5],al
    12e2:	8a 05 15 41 01 00    	mov    al,BYTE PTR [rip+0x14115]        # 153fd <stdin@GLIBC_2.2.5+0x3ad>
    12e8:	f7 d0                	not    eax
    12ea:	83 e0 01             	and    eax,0x1
    12ed:	88 44 24 b7          	mov    BYTE PTR [rsp-0x49],al
    12f1:	8a 05 6c 3d 01 00    	mov    al,BYTE PTR [rip+0x13d6c]        # 15063 <stdin@GLIBC_2.2.5+0x13>
    12f7:	f7 d0                	not    eax
    12f9:	88 44 24 fc          	mov    BYTE PTR [rsp-0x4],al
    12fd:	8a 05 f5 40 01 00    	mov    al,BYTE PTR [rip+0x140f5]        # 153f8 <stdin@GLIBC_2.2.5+0x3a8>
    1303:	f7 d0                	not    eax
    1305:	83 e0 01             	and    eax,0x1
    1308:	88 44 24 b8          	mov    BYTE PTR [rsp-0x48],al
    130c:	8a 05 80 3e 01 00    	mov    al,BYTE PTR [rip+0x13e80]        # 15192 <stdin@GLIBC_2.2.5+0x142>
    1312:	f7 d0                	not    eax
    1314:	88 44 24 fd          	mov    BYTE PTR [rsp-0x3],al
    1318:	8a 05 14 41 01 00    	mov    al,BYTE PTR [rip+0x14114]        # 15432 <stdin@GLIBC_2.2.5+0x3e2>
    131e:	f7 d0                	not    eax
```

Yang bikin ini “enak” buat disolve:
- check function hampir pure **combinational logic**: `mov/and/or/not` tanpa branching.
- artinya kita bisa *symbolically evaluate* langsung jadi ekspresi boolean/bitvector.

Di ujung fungsi, bentuknya jadi rantai operasi bitwise panjang. Tail-nya (biar kebayang) seperti ini:

```bash
$ objdump -d -Mintel --start-address=0x1288f --stop-address=0x12910 three_sat_problem

three_sat_problem:     file format elf64-x86-64


Disassembly of section .text:

000000000001288f <.text+0x117ff>:
   1288f:	21 c2                	and    edx,eax
   12891:	8a 05 e6 28 00 00    	mov    al,BYTE PTR [rip+0x28e6]        # 1517d <stdin@GLIBC_2.2.5+0x12d>
   12897:	22 05 be 2c 00 00    	and    al,BYTE PTR [rip+0x2cbe]        # 1555b <stdin@GLIBC_2.2.5+0x50b>
   1289d:	f7 d0                	not    eax
   1289f:	83 e0 01             	and    eax,0x1
   128a2:	0a 05 fe 27 00 00    	or     al,BYTE PTR [rip+0x27fe]        # 150a6 <stdin@GLIBC_2.2.5+0x56>
   128a8:	21 ce                	and    esi,ecx
   128aa:	f7 d6                	not    esi
   128ac:	21 c6                	and    esi,eax
   128ae:	8a 44 24 fa          	mov    al,BYTE PTR [rsp-0x6]
   128b2:	0a 05 a3 2c 00 00    	or     al,BYTE PTR [rip+0x2ca3]        # 1555b <stdin@GLIBC_2.2.5+0x50b>
   128b8:	21 f0                	and    eax,esi
   128ba:	40 8a 74 24 fb       	mov    sil,BYTE PTR [rsp-0x5]
   128bf:	40 0a 35 e0 27 00 00 	or     sil,BYTE PTR [rip+0x27e0]        # 150a6 <stdin@GLIBC_2.2.5+0x56>
   128c6:	21 c6                	and    esi,eax
   128c8:	8a 44 24 fb          	mov    al,BYTE PTR [rsp-0x5]
   128cc:	0a 05 a0 28 00 00    	or     al,BYTE PTR [rip+0x28a0]        # 15172 <stdin@GLIBC_2.2.5+0x122>
   128d2:	21 f0                	and    eax,esi
   128d4:	40 8a 74 24 fc       	mov    sil,BYTE PTR [rsp-0x4]
   128d9:	40 0a 35 41 2a 00 00 	or     sil,BYTE PTR [rip+0x2a41]        # 15321 <stdin@GLIBC_2.2.5+0x2d1>
   128e0:	21 f0                	and    eax,esi
   128e2:	40 8a 74 24 fc       	mov    sil,BYTE PTR [rsp-0x4]
   128e7:	40 0a 35 0f 2b 00 00 	or     sil,BYTE PTR [rip+0x2b0f]        # 153fd <stdin@GLIBC_2.2.5+0x3ad>
   128ee:	21 c6                	and    esi,eax
   128f0:	8a 44 24 fd          	mov    al,BYTE PTR [rsp-0x3]
   128f4:	0a 05 69 27 00 00    	or     al,BYTE PTR [rip+0x2769]        # 15063 <stdin@GLIBC_2.2.5+0x13>
   128fa:	21 f0                	and    eax,esi
   128fc:	40 8a 74 24 fd       	mov    sil,BYTE PTR [rsp-0x3]
   12901:	0b 35 f1 2a 00 00    	or     esi,DWORD PTR [rip+0x2af1]        # 153f8 <stdin@GLIBC_2.2.5+0x3a8>
   12907:	21 f0                	and    eax,esi
   12909:	40 8a 35 6c 27 00 00 	mov    sil,BYTE PTR [rip+0x276c]        # 1507c <stdin@GLIBC_2.2.5+0x2c>
```

Kalau dibaca mentah-mentah, ini “menyiksa”. Jadi kita geser strategi:

> Alih-alih memanusiakan boolean circuit 70KB, kita suruh saja Z3.

---

### Solver: symbolic execution mini + Z3

Konsepnya simpel:

- **SAT**: cari assignment boolean yang bikin formula bernilai true.
- Di sini, formula itu bukan file CNF, tapi *hasil komputasi assembly*.
- **SMT solver (Z3)** bisa menangani ekspresi bitvector seperti `AND/OR/NOT` dengan constraint tambahan.

Triknya:
1) Parse instruction bytes dari `0x1289..0x12981`
2) Emulate instruction yang muncul (`mov`, `and`, `or`, `xor`, `not`) tapi bukan dengan angka konkret—melainkan dengan **simbol Z3**
3) Model input sebagai 1279 bit (`b0..b1278`), lalu lift jadi byte ASCII `'0'`/`'1'`
4) Tambah constraint `b[0x2f2] == 1` dan `AL != 0`
5) Minta Z3 ngasih model (assignment), feed ke binary, ambil flag

Setup dependency (di environment ini aku pakai venv):

```bash
$ python3 -m venv .venv
$ . .venv/bin/activate
$ python -m pip install z3-solver capstone pyelftools
```

Run solver:

```bash
$ . .venv/bin/activate && python solve.py
lactf{is_the_three_body_problem_np_hard}
```

Solver code:

```python
#!/usr/bin/env python3
from __future__ import annotations

"""
LACTF rev: the-three-sat-problem

High-level idea:
- The binary reads a 1279-char string of '0'/'1' into a global buffer at 0x15060.
- It calls a huge, branchless function (0x1289..0x12981) that computes a boolean-ish
  expression using only byte-level NOT/AND/OR/XOR.
- If that function returns non-zero in AL and input[0x2f2] == '1', the program
  "decrypts" a 320-bit message by selecting bits from the input and prints the flag.

Instead of decompiling the entire boolean circuit by hand, we:
1) Disassemble the check function bytes from the ELF .text section.
2) Symbolically emulate only the instructions we actually see (mov/and/or/xor/not).
3) Model each input char as a 1-bit variable (0 or 1), then lift it to 0x30/0x31.
4) Ask Z3 for any satisfying assignment that makes AL != 0.
"""

import subprocess
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Tuple

import z3
from capstone import CS_ARCH_X86, CS_MODE_64, Cs
from capstone.x86 import X86_OP_IMM, X86_OP_MEM, X86_OP_REG, X86_REG_RIP, X86_REG_RSP
from elftools.elf.elffile import ELFFile

BASE_INPUT = 0x15060
INPUT_LEN = 0x4FF  # 1279 bytes of '0'/'1'
BIT_MUST_BE_ONE = 0x2F2  # main() additionally checks (input[0x2f2] & 1) == 1

FUNC_START = 0x1289
FUNC_END = 0x12982


def _canon_low8(reg_name: str) -> str:
    # Capstone may report e.g. eax/rax; we only track the low 8-bit view.
    reg_name = reg_name.lower()
    mapping = {
        "al": "al",
        "eax": "al",
        "rax": "al",
        "bl": "bl",
        "ebx": "bl",
        "rbx": "bl",
        "cl": "cl",
        "ecx": "cl",
        "rcx": "cl",
        "dl": "dl",
        "edx": "dl",
        "rdx": "dl",
        "sil": "sil",
        "esi": "sil",
        "rsi": "sil",
        "dil": "dil",
        "edi": "dil",
        "rdi": "dil",
        "bpl": "bpl",
        "ebp": "bpl",
        "rbp": "bpl",
        "spl": "spl",
        "esp": "spl",
        "rsp": "spl",
    }
    if reg_name in mapping:
        return mapping[reg_name]
    for i in range(8, 16):
        if reg_name in {f"r{i}b", f"r{i}d", f"r{i}"}:
            return f"r{i}b"
    return reg_name


@dataclass
class MemRef:
    kind: str  # "input" | "stack"
    key: int  # input abs addr for kind=input; stack displacement for kind=stack


def _read_text_bytes(path: Path, vaddr: int, size: int) -> bytes:
    # Read raw instruction bytes from ELF .text at a given virtual address.
    with path.open("rb") as f:
        elf = ELFFile(f)
        text = elf.get_section_by_name(".text")
        if text is None:
            raise RuntimeError("missing .text section")
        text_addr = text["sh_addr"]
        text_off = text["sh_offset"]
        if not (text_addr <= vaddr < text_addr + text["sh_size"]):
            raise RuntimeError("address not in .text")
        start_off = text_off + (vaddr - text_addr)
        f.seek(start_off)
        return f.read(size)


def _memref(insn_addr: int, insn_size: int, mem) -> MemRef:
    # Convert a Capstone memory operand into either:
    # - a RIP-relative reference into the input buffer at 0x15060, or
    # - an RSP-relative stack slot.
    base = mem.base
    if base == X86_REG_RIP:
        abs_addr = insn_addr + insn_size + mem.disp
        if not (BASE_INPUT <= abs_addr < BASE_INPUT + INPUT_LEN):
            raise RuntimeError(f"unexpected RIP-relative address: {hex(abs_addr)}")
        return MemRef("input", abs_addr)
    if base == X86_REG_RSP:
        return MemRef("stack", mem.disp)
    raise RuntimeError(f"unexpected mem base reg: {base}")


def _imm8(v: int) -> z3.BitVecRef:
    return z3.BitVecVal(v & 0xFF, 8)


def _bv8_from_bit(bit1: z3.BitVecRef) -> z3.BitVecRef:
    # Input characters are ASCII '0' or '1'.
    # We encode them as 0x30 + bit, so bit=0 -> '0', bit=1 -> '1'.
    return z3.BitVecVal(0x30, 8) + z3.ZeroExt(7, bit1)


def build_return_al(path: Path) -> Tuple[z3.BitVecRef, List[z3.BitVecRef]]:
    # Symbolically execute the check function and return:
    # - the final AL value (8-bit bitvector)
    # - the list of 1-bit input variables
    code = _read_text_bytes(path, FUNC_START, FUNC_END - FUNC_START)
    md = Cs(CS_ARCH_X86, CS_MODE_64)
    md.detail = True

    # One Boolean variable per input position (1279 total).
    bits = [z3.BitVec(f"b{i}", 1) for i in range(INPUT_LEN)]

    # We track only 8-bit slices for regs used in the function.
    regs: Dict[str, z3.BitVecRef] = {}
    # Stack slots are 1-byte temporaries at [rsp+disp].
    stack: Dict[int, z3.BitVecRef] = {}
    stack_written = set()

    def reg8(reg_id: int) -> str:
        name = md.reg_name(reg_id)
        c = _canon_low8(name)
        if c == "rip":
            raise RuntimeError("rip used as value reg")
        return c

    def get_reg(name: str) -> z3.BitVecRef:
        return regs.get(name, z3.BitVecVal(0, 8))

    def set_reg(name: str, value: z3.BitVecRef) -> None:
        regs[name] = z3.simplify(value)

    def load_mem(mr: MemRef) -> z3.BitVecRef:
        if mr.kind == "input":
            # Read input byte: either 0x30 or 0x31, based on the input bit variable.
            idx = mr.key - BASE_INPUT
            return _bv8_from_bit(bits[idx])
        if mr.kind == "stack":
            if mr.key not in stack_written:
                raise RuntimeError(f"uninitialized stack read at disp {mr.key:+#x}")
            return stack[mr.key]
        raise AssertionError(mr)

    def store_mem(mr: MemRef, v: z3.BitVecRef) -> None:
        if mr.kind != "stack":
            raise RuntimeError("unexpected store to non-stack memory")
        stack[mr.key] = z3.simplify(v)
        stack_written.add(mr.key)

    def op_val(op) -> z3.BitVecRef:
        if op.type == X86_OP_IMM:
            return _imm8(op.imm)
        if op.type == X86_OP_REG:
            return get_reg(reg8(op.reg))
        if op.type == X86_OP_MEM:
            return load_mem(_memref(insn.address, insn.size, op.mem))
        raise RuntimeError(f"unsupported operand type: {op.type}")

    for insn in md.disasm(code, FUNC_START):
        mnem = insn.mnemonic
        ops = insn.operands

        # Prologue/epilogue noise (we don't model RSP movement).
        if mnem in {"push", "pop", "sub", "add", "ret"}:
            continue

        if mnem == "mov":
            if len(ops) != 2:
                raise RuntimeError("unexpected mov operands")
            dst, src = ops
            v = op_val(src)
            if dst.type == X86_OP_REG:
                set_reg(reg8(dst.reg), v)
            elif dst.type == X86_OP_MEM:
                store_mem(_memref(insn.address, insn.size, dst.mem), v)
            else:
                raise RuntimeError("unsupported mov destination")
            continue

        if mnem in {"and", "or", "xor"}:
            if len(ops) != 2 or ops[0].type != X86_OP_REG:
                raise RuntimeError(f"unsupported {mnem} form")
            dst_name = reg8(ops[0].reg)
            a = get_reg(dst_name)
            b = op_val(ops[1])
            # Bitvector-level boolean ops (8-bit wide).
            if mnem == "and":
                out = a & b
            elif mnem == "or":
                out = a | b
            else:
                out = a ^ b
            set_reg(dst_name, out)
            continue

        if mnem == "not":
            if len(ops) != 1 or ops[0].type != X86_OP_REG:
                raise RuntimeError("unsupported not form")
            dst_name = reg8(ops[0].reg)
            set_reg(dst_name, ~get_reg(dst_name))
            continue

        raise RuntimeError(f"unsupported mnemonic: {mnem} @ {hex(insn.address)}")

    return get_reg("al"), bits


def solve_assignment(path: Path) -> str:
    # Constrain the model so the program takes the success path:
    # - input[0x2f2] must be '1'
    # - the check function must return AL != 0
    al, bits = build_return_al(path)
    s = z3.Solver()
    s.add(bits[BIT_MUST_BE_ONE] == z3.BitVecVal(1, 1))
    s.add(al != z3.BitVecVal(0, 8))

    if s.check() != z3.sat:
        raise RuntimeError("unsat (unexpected)")
    m = s.model()

    out = []
    for b in bits:
        out.append("1" if m.eval(b, model_completion=True).as_long() & 1 else "0")
    return "".join(out)


def run_and_get_flag(path: Path, assignment: str) -> str:
    # Feed the satisfying assignment to the binary and scrape the printed flag.
    p = subprocess.run(
        [str(path)],
        input=(assignment + "\n").encode(),
        stdout=subprocess.PIPE,
        stderr=subprocess.DEVNULL,
        check=False,
        timeout=10,
    )
    lines = p.stdout.decode(errors="replace").splitlines()
    # Expected:
    # 0: prompt
    # 1: Incredible!...
    # 2: flag
    for line in lines:
        if "lactf{" in line:
            return line.strip()
    return "\n".join(lines[-3:]).strip()


def main() -> None:
    bin_path = Path(__file__).with_name("three_sat_problem")
    assignment = solve_assignment(bin_path)
    flag = run_and_get_flag(bin_path, assignment)
    print(flag)


if __name__ == "__main__":
    main()
```

---

### Pseudocode “Three-Sat”

#### `main` (sekitar `0x1090`)

```text
print("Have you solved the Three-Sat Problem?")
s = fgets(buf=0x15060, size=0x500, stdin)
strip_newline(s)

if strlen(s) != 0x4ff:
    puts("Please be serious...")
    exit(1)

for i in range(0x4ff):
    if s[i] not in {'0','1'}:
        puts("Please be serious...")
        exit(1)

ok = sat_check()          # call 0x1289, result in AL
if ok == 0:
    puts("I see you haven't.")
    exit(1)

# extra constraint:
if (s[0x2f2] & 1) == 0:   # address 0x15060+0x2f2 = 0x15352
    puts("I see you haven't.")
    exit(1)

puts("Incredible! Let me get the flag for you...")

# build 40-byte string from 320 selected input bits, table at 0x13080
out = bytearray(41)  # zeroed, includes null terminator
for bitpos in range(0x140):         # 320 bits
    idx = table_0x13080[bitpos]     # dword index into input
    b = (s[idx] & 1)
    out[bitpos >> 3] |= b << (bitpos & 7)

puts(out)  # prints flag
```

#### `sat_check` (fungsi raksasa di `0x1289..0x12981`)

```text
# boolean circuit, no branches
# xi = (input[i] & 1)  for i in 0..1278
# function computes a long expression F(x0..x1278) using NOT/AND/OR (byte-wide)
# return (F != 0) in AL
```

Kalau kamu mau “lebih literal”, awal fungsi itu bisa dibaca sebagai:

```text
t0 = (~input[0x000]) & 1
t1 = (~input[0x4fb]) & 1
t2 = (~input[0x046])     # dst disimpan sebagai byte, lalu dipakai via AND/OR berikutnya
...
```

Di sinilah Z3 bersinar: kita gak perlu menuliskan F satu per satu—cukup **modelkan instruction stream** jadi ekspresi simbolik.


### Reference

- [SAT vs SMT (konsep dasar)](https://en.wikipedia.org/wiki/Satisfiability_modulo_theories)
