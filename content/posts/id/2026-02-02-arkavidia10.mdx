---
layout: post
title: "Arkavidia 10 - Reverse Engineering"
date: 2026-02-02
image: /assets/.
categories: ["Arkavidia"]
tags: [rev, ctf2026]
---


## Deadliner

### Intro

Challenge ini rasanya kayak “mobile app tugas 2 bulan yang divibecode 3 hari”: UI-nya rapi, flow login/register ada, tapi… bagian security-nya “cukup buat demo”. Dan itulah pintu masuknya.

Target kita sederhana: **ambil flag dari APK**. Tapi karena ini Flutter (AOT), kita nggak bakal dapat source Dart mentah. Jadi pendekatannya: recon dulu biar tahu ini app jenis apa, lalu bongkar `libapp.so` sampai nemu jalur validasi kredensial, dan akhirnya **balik (invert) algoritma hash** buat recover password yang ternyata… flag.

---

### Recon: “ini APK Flutter, mana logic-nya?”

Mulai dari satu file:

```bash
ls -la
file dist.apk
unzip -l dist.apk | head -n 40
```

Output pentingnya:

- Ada `assets/flutter_assets/...` dan `lib/*/libflutter.so` + `lib/*/libapp.so`
- Itu tanda khas **Flutter release (AOT)**: logic app ada di `libapp.so`, bukan `classes.dex`.

Langkah berikutnya: ekstrak APK biar gampang di-grep.

```bash
mkdir -p out/apk
unzip -q -o dist.apk -d out/apk
```

Biasanya aku coba cari flag cepat dulu (kadang developer “khilaf” naruh string flag mentah):

```bash
rg -a -n "flag\\{|FLAG\\{|arkav\\{|ctf\\{" out/apk || true
strings -a out/apk/classes.dex | rg -i 'flag|arkav|ctf' | head
```

Hasilnya nihil. Oke, berarti ini bukan “strings ez win”.

---

### Triage cepat di `libapp.so`: ada login, ada admin, ada sesuatu yang panjang banget

Flutter AOT itu noisy kalau cuma pakai `strings`, tapi tetap berguna buat nyari “anchor”:

```bash
strings -a out/apk/lib/x86_64/libapp.so | rg -n "Admin Panel|LoginScreen|RegisterScreen|password_db\\.dart|hash_algorithm\\.dart" | head -n 50
```

Satu hal yang bikin aku berhenti sejenak: ada file path Dart yang kebawa ke binary, contohnya:

- `package:simple_mobile_app/utils/password_db.dart`
- `package:simple_mobile_app/utils/hash_algorithm.dart`

Artinya: ada modul “password db” dan ada “hash algorithm” custom. Ini biasanya jackpot untuk chall rev, karena:

1) stored hash pasti ada di satu tempat,
2) hash-nya biasanya “homebrew crypto” (read: reversible atau lemah),
3) cukup invert untuk recover password.

Dan bener aja: di `libapp.so` ada string hex panjang banget yang kelihatan kayak digest.

---

### Naik level: dump simbol Dart AOT pakai Blutter

Karena ini Flutter AOT, cara paling nyaman adalah pakai **Blutter** buat:

- dump object pool (konstanta: string, map, list),
- generate pseudo-assembly per file `package:...`.

Setup minimal:

```bash
apt-get install -y -qq cmake ninja-build pkg-config libicu-dev libcapstone-dev python3-pyelftools python3-requests
```

Clone Blutter dan jalanin ke folder `arm64-v8a` (Blutter fokusnya arm64):

```bash
git clone --depth 1 https://github.com/worawit/blutter.git out/blutter
python3 out/blutter/blutter.py out/apk/lib/arm64-v8a out/blutter_out
```

Output yang kita pakai:

- `out/blutter_out/asm/simple_mobile_app/utils/password_db.dart`
- `out/blutter_out/asm/simple_mobile_app/utils/hash_algorithm.dart`
- `out/blutter_out/asm/simple_mobile_app/services/analytics_service.dart`
- `out/blutter_out/pp.txt` (object pool, konstanta)

---

### Temuan 1: “database password” cuma 1 user — `superadmin`

Di `out/blutter_out/asm/simple_mobile_app/utils/password_db.dart`, ada initializer map yang literally hardcode:

- Function: `PasswordDB._passwordHashes()` di **addr `0x3216b4`**
- Key: **`"superadmin"`**
- Value: string hex (digest) panjang

Potongan relevan (dari dump Blutter):

- `"superadmin"`: `out/blutter_out/asm/simple_mobile_app/utils/password_db.dart:75`
- digest hex: `out/blutter_out/asm/simple_mobile_app/utils/password_db.dart:80`

Dan beneran cuma itu doang: map literal size 1.

Kalau kamu mau “bukti", bagian init-nya kelihatan kayak gini:

```asm
; PasswordDB._passwordHashes @ 0x3216b4
0x3216d8: r16 = "superadmin"
;           [pp+0xcd08] "superadmin"
0x3216e4: r16 = "ff9841831ca972c5...4c4a65869"
;           [pp+0xcd50] "<digest hex>"
```

Secara konsep, pseudocode-nya:

```text
// PasswordDB._passwordHashes @ 0x3216b4
passwordHashes = {
  "superadmin": "ff9841831ca972c5...4c4a65869"
}
```

Jadi challenge ini bukan “cari username random”: username sudah dikasih secara implisit.

---

### Temuan 2: ada “session params” per user yang jadi key hashing

Di `out/blutter_out/asm/simple_mobile_app/services/analytics_service.dart` ada:

- Function: `AnalyticsService.getSessionParams` di **addr `0x322028`**
- Dia ngecek map konstanta (object pool) yang isinya:

```bash
rg -n "Map<String, List<int>>\\(1\\)" out/blutter_out/pp.txt | head
sed -n '12510,12520p' out/blutter_out/pp.txt
```

Isinya:

```text
Map<String, List<int>>(1) {
  "superadmin": List<int>(2) [0xd15ea5e, 0x41414141]
}
```

Dan pemanggilan konstanta map itu keliatan jelas dari reference pool:

```asm
; AnalyticsService.getSessionParams @ 0x322028
0x32204c: ... ; [pp+0xcd78] Map<String, List<int>>(1)
```

Pseudocode:

```text
// AnalyticsService.getSessionParams @ 0x322028
sessionParams = {
  "superadmin": [0x0d15ea5e, 0x41414141]
}
return sessionParams[username] ?? []
```

Nah ini yang menarik: hashing-nya ternyata “keyed”, tapi key-nya juga hardcoded.

---

### Temuan 3 (inti): algoritma hash-nya bisa dibalik

File paling penting: `out/blutter_out/asm/simple_mobile_app/utils/hash_algorithm.dart`.

Yang kita peduli:

- `HashAlgorithm.verify` @ **`0x321a4c`** (wrapper yang memanggil hash lalu compare)
- `HashAlgorithm.hash` @ **`0x321aa0`**
- Helper:
  - `XOR_Username` @ **`0x321e50`**
  - `rotate_right_6` @ **`0x321ee4`**
  - `rotate_left_3` @ **`0x321f1c`**
  - `XOR_0x0D15EA5E` @ **`0x321f58`** (intinya XOR pakai byte dari key dword)

#### Bentuk algoritmanya (pseudocode dari ASM)

Kalau diringkas dari flow di `HashAlgorithm.hash`:

```text
// HashAlgorithm.hash @ 0x321aa0
// input: passwordBytes, username
keys = AnalyticsService.getSessionParams(username)
if keys == null or len(keys) < 2: return ""

k1 = keys[0]  // 0x0d15ea5e
k2 = keys[1]  // 0x41414141

out = []
for i, b in enumerate(passwordBytes):
    b = b ^ byte(k1, i)          // ambil salah 1 byte dari k1 (i % 4)
    b = rol8(b, 3)
    b = b ^ byte(k2, i)          // ambil salah 1 byte dari k2 (i % 4)
    b = ror8(b, 6)
    b = b ^ username[i % len(username)]
    out.append(b)

return hex(out)  // tiap byte -> 2 digit hex, lalu join
```

Potongan kecil dari helper yang bikin “username ikut jadi key”:

```asm
; HashAlgorithm.XOR_Username @ 0x321e50
0x321e68: sdiv  x6, x2, x0          ; i / len(username)
0x321e6c: msub  x5, x6, x0, x2      ; i % len(username)
...
0x321eac: eor   x0, x4, x1          ; byte ^ username[i % len]
```

Kunci utamanya: semua operasinya adalah XOR + rotasi bit 8-bit → **invertible**.

Jadi kalau kita punya:

- username: `superadmin`
- key: `[0x0d15ea5e, 0x41414141]`
- digest hex: `ff9841...`

…kita bisa jalanin inverse untuk recover password asli.

---

### Exploit: invert digest → dapet password → password = flag

Forward-nya:

```text
passwordByte -> XOR(k1) -> ROL3 -> XOR(k2) -> ROR6 -> XOR(usernameByte) -> digestByte
```

Maka inverse-nya (dibalik dari kanan ke kiri):

```text
digestByte -> XOR(usernameByte) -> ROL6 -> XOR(k2) -> ROR3 -> XOR(k1) -> passwordByte
```

Implementasi Python (ini yang kupakai buat recover flag):

```py
hash_hex = "ff9841831ca972c540e6c035d2c4c1026ea63c4bd11fc32df02d700deb44a79d192ec129cec4da06799c4e26f92d1a2d26272d15594ee74b4e217d8659b4c306b02d1a6e264726dd3f0e84216e84574b99f4c4a65869"
username = "superadmin"
k1 = 0x0d15ea5e
k2 = 0x41414141

def rotl8(x, n): return ((x << n) | (x >> (8 - n))) & 0xff
def rotr8(x, n): return ((x >> n) | (x << (8 - n))) & 0xff

k1b = [(k1 >> 24) & 0xff, (k1 >> 16) & 0xff, (k1 >> 8) & 0xff, k1 & 0xff]
k2b = [(k2 >> 24) & 0xff, (k2 >> 16) & 0xff, (k2 >> 8) & 0xff, k2 & 0xff]
uname = username.encode()

digest = bytes.fromhex(hash_hex)
pw = []
for i, s in enumerate(digest):
    o = s ^ uname[i % len(uname)]
    e = rotl8(o, 6)           # inverse dari ROR6
    c = e ^ k2b[i % 4]
    b = rotr8(c, 3)           # inverse dari ROL3
    p = b ^ k1b[i % 4]
    pw.append(p)

print(bytes(pw).decode())
```

Outputnya langsung printable ASCII, dan isinya flag.

### Flag 

`ARKAV{r3ly_t00_much_0n_41_bu1ld1ng_4pp_5ur3ly_1t_w0uldn't_b1t3_m3_1n_th3_futur3_r1ght}`


---

## him

### Intro

> “Huh? Even though I’m a guy? Have you finally lost your mind, you cosmetic fanatic?”  
> “Treat me to Tenya Ramen, three times. Any less than that and it’s not happening.”

Challenge ini kelihatannya sederhana: sebuah binary kecil bernama `him` yang minta kita kasih `./him <flag>`. Tapi begitu salah input… dia malah *segfault*. Dan di situlah “ceritanya” dimulai: bukan brute-force, tapi membedah sebuah VM mini + self-modifying bytecode sampai akhirnya kita bisa “mengucapkan” nama *HIM* dengan benar.

`ARKAV{C4nn07_5p311_h1ur4_m1h473_w17h0u7_H1M}`

---

### Recon: “kok salah flag malah crash?”

Pertama, cek isi folder:

```bash
$ ls -la
him.zip
```

Unzip dan jalankan:

```bash
$ unzip him.zip
$ chmod +x him
$ ./him
Usage: ./him <flag>
```

Kalau kita kasih input random:

```bash
$ ./him test
# (tidak ada output)
$ echo $?
139
```

Exit code `139` = segfault. Ini bukan “fitur keamanan”, tapi sinyal bahwa logic checker-nya sengaja bikin state internal rusak (atau ada VM yang nulis ke alamat ngawur) ketika validasi gagal.

Karena binary **not stripped**, kita dapat banyak hadiah dari awal:

```bash
$ file him
him: ELF 64-bit LSB pie executable, x86-64, dynamically linked, not stripped
```

PIE artinya alamat runtime bakal `base + offset`. Di write-up ini aku pakai **offset** dari hasil `nm/objdump`.

---

### Mapping: fungsi dan data penting

```bash
$ nm -an him | rg 'rdtsc|encode_input|vm_cpu|main|bytecode|reward|reward_len|sp_cookie|encrypted_sp'
0000000000002169 T rdtsc
0000000000002187 T encode_input
000000000000222f T vm_cpu
0000000000002ada T main
0000000000005040 D bytecode
0000000000005140 D reward
0000000000005174 D reward_len
0000000000005178 D sp_cookie
000000000000517c D encrypted_sp
```

Intuisi awal ku adalah:

- `encode_input()` mengubah input user jadi buffer global `encoded_input` (di `.bss`, offset `0x69a0`).
- `bytecode` (di `.data` `0x5040`) dan `dispatch_table` (di `.data` `0x5180`) membentuk sebuah **VM**.
- `reward` (`0x5140`) + `reward_len` (`0x5174`) dipakai buat nge-print output setelah validasi lewat.

---

### Main: tiga langkah yang “jahat”

Disassembly inti `main` (offset `0x2ada`) intinya begini:

1. Cek argumen (`argc == 2`), kalau tidak -> `printf("Usage: %s <flag>")`.
2. Panggil `encode_input(argv[1])`.
3. **Dekrip bytecode in-place**: semua byte `bytecode[i] ^= 0x55` untuk `i = 0..0xe4` (229 byte).
4. Panggil `vm_cpu(strlen(argv[1]))`.

Jadi bytecode aslinya *terenkripsi*, baru dibuka saat runtime.

---

#### Bagian 1 — encode_input(): “flag”-nya tidak dicek langsung

`encode_input` (offset `0x2187`) bikin array `encoded_input` yang nantinya jadi “bahan bakar” VM.

Pseudocode-nya:

```c
// encode_input(input: char*)
// output ditaruh di global encoded_input[0..len-1]

uint8_t state = 0xA7;
int n = min(strlen(input), 0xFF);

for (int i = 0; i < n; i++) {
    uint8_t b = (uint8_t)input[i];
    uint8_t e = (uint8_t)((b ^ state) + (13 * i));   // 13*i mod 256
    encoded_input[i] = e;

    // state = e ^ (state*7)   (mod 256)
    state = (uint8_t)(e ^ (uint8_t)(state * 7));
}
```

Artinya: VM **tidak pernah** membandingkan input plaintext langsung. Yang dicek adalah `encoded_input[i]` (hasil encoding).

Bonus penting: fungsi ini bisa kita **invert** untuk dapetin input asli begitu kita tahu semua `encoded_input[i]`.

---

#### Bagian 2 — vm_cpu(): VM stack + bytecode yang memodifikasi dirinya sendiri

`vm_cpu` (offset `0x222f`) adalah interpreter sederhana, dengan:

- `bytecode` di `.data` (`0x5040`)
- `dispatch_table` di `.data` (`0x5180`) berisi 256 function pointer (kebanyakan mengarah ke `exit(0x8b)`).
- `stack` global di `.bss` (`0x59a0`) sebagai stack VM (elemen 32-bit)
- `encoded_input` global di `.bss` (`0x69a0`) sebagai “register file” input

#### “Stack pointer terenkripsi” (kenapa bisa segfault)

Ada dua global:

- `sp_cookie` (u32) di `0x5178`
- `encrypted_sp` (u32) di `0x517c`

Setiap push/pop, SP dihitung dengan:

```
sp = sp_cookie ^ encrypted_sp
```

Kalau checker gagal di beberapa opcode, dia **meng-XOR `sp_cookie` dengan konstanta magic** (misal `0xdeadbeef`, `0xcafebabe`). Setelah itu, SP jadi ngawur → index stack jadi negatif/di luar range → nulis ke alamat random → segfault (ini yang kita lihat saat input salah).

#### Opcode yang relevan (dan alamat handler)

Dari `dispatch_table` kita bisa mapping opcode → handler (offset):

| Opcode | Char | Handler (offset) | Makna |
|---:|:---:|---:|---|
| 0x48 | `H` | 0x2277 | `PUSH_IMM` (push 1 byte immediate dari bytecode) |
| 0x49 | `I` | 0x231b | `PUSH_INP idx` (push `encoded_input[idx]`) |
| 0x55 | `U` | 0x23e9 | `ADD` |
| 0x52 | `R` | 0x24ff | `XOR` |
| 0x41 | `A` | 0x2613 | `ASSERT_EQ imm` (compare pop dengan immediate byte berikutnya) |
| 0x6d | `m` | 0x26c1 | `ASSERT_M imm` (check transform tertentu) |
| 0x69 | `i` | 0x278d | `JMP (top ^ imm)` |
| 0x74 | `t` | 0x2940 | XOR-blok bytecode: `len, key` |
| 0x68 | `h` | 0x2851 | anti-debug-ish: pilih `0xCC`/`0xAD` via `rdtsc`, lalu XOR 4 byte bytecode |
| 0x61 | `a` | 0x2a1f | NOP (advance ip) |
| 0x65 | `e` | 0x2a56 | “reward printer” (print output lalu `exit(0)`) |

Opcode lain → `exit(0x8b)`.

#### Transform `m`: matematikanya bisa dibalik

Handler `m` pada dasarnya ngecek:

```c
// val = pop()
// imm = next byte in bytecode
uint8_t t = (uint8_t)(((val + 13) * 3) & 0xFF);
t ^= 0x55;
assert(t == imm);
```

Karena `3` punya invers mod 256 (`171`, karena `3*171 ≡ 1 (mod 256)`), constraint ini bisa di-invert:

```text
imm' = imm ^ 0x55
val  = (imm' * 171 - 13) mod 256
```

Jadi `m` juga ujungnya “mengunci” satu byte `encoded_input[idx]`.

---

### Bagian 3 — “exploit”-nya: jangan lawan VM, emulasikan dan curi constraint

Di sini titik baliknya:

- Bytecode VM isinya cuma operasi `ADD`, `XOR`, `ASSERT` terhadap immediate.
- Artinya banyak constraint yang **langsung menyelesaikan** `encoded_input[i]` jadi angka tertentu.
- Satu yang bikin ribet: opcode `i` (`JMP`) butuh nilai runtime (`encoded_input[idx]`) untuk menentukan `ip` lompat ke mana.

Solusi:

1. Emulasikan VM.
2. Representasikan stack sebagai ekspresi sederhana (`Var(idx)`, `Const`, `Add`, `Xor`).
3. Saat ketemu `ASSERT_EQ` atau `ASSERT_M`:
   - Kalau ekspresinya `Var(i)` / `Var(i) ^ c` / `Var(i) + c`, kita bisa langsung assign nilai `encoded_input[i]`.
4. Saat ketemu `JMP` dan stack top masih `Var(i)`:
   - Lakukan BFS/branch kecil: coba 0..255 untuk `encoded_input[i]`, lanjutkan yang tidak “mati”.
5. Begitu berhasil mencapai opcode `e`, kita punya cukup `encoded_input[0..43]`.
6. Invert `encode_input` untuk dapetin input plaintext: itulah flag.

### Script solver

Script berikut yang aku pakai.

`solve.py`:

```py
#!/usr/bin/env python3
import pathlib
import collections

BIN = pathlib.Path("him").read_bytes()

DATA_VA  = 0x5020
DATA_OFF = 0x4020

BYTECODE_VA  = 0x5040
BYTECODE_LEN = 229
REWARD_VA    = 0x5140
REWARD_LEN   = 52

def va_to_off(va: int) -> int:
    return (va - DATA_VA) + DATA_OFF

bytecode_enc = bytearray(BIN[va_to_off(BYTECODE_VA):va_to_off(BYTECODE_VA)+BYTECODE_LEN])
reward       = BIN[va_to_off(REWARD_VA):va_to_off(REWARD_VA)+REWARD_LEN]

# main() decrypts bytecode in-place: bytecode[i] ^= 0x55
bytecode0 = bytearray(b ^ 0x55 for b in bytecode_enc)

# --- tiny symbolic layer (cukup buat ADD/XOR + konstanta) ---
class Expr: pass
class Const(Expr):
    __slots__ = ("v",)
    def __init__(self, v): self.v = v & 0xFFFFFFFF
class Var(Expr):
    __slots__ = ("i",)
    def __init__(self, i): self.i = int(i)
class Xor(Expr):
    __slots__ = ("a","b")
    def __init__(self, a, b): self.a=a; self.b=b
class Add(Expr):
    __slots__ = ("a","b")
    def __init__(self, a, b): self.a=a; self.b=b

def simplify(e: Expr, env: dict[int,int]) -> Expr:
    if isinstance(e, Const): return e
    if isinstance(e, Var):
        return Const(env[e.i]) if e.i in env else e
    if isinstance(e, Xor):
        a = simplify(e.a, env); b = simplify(e.b, env)
        if isinstance(a, Const) and isinstance(b, Const): return Const(a.v ^ b.v)
        # keep const on right
        if isinstance(a, Const) and not isinstance(b, Const): a, b = b, a
        return Xor(a, b)
    if isinstance(e, Add):
        a = simplify(e.a, env); b = simplify(e.b, env)
        if isinstance(a, Const) and isinstance(b, Const): return Const((a.v + b.v) & 0xFFFFFFFF)
        if isinstance(a, Const) and not isinstance(b, Const): a, b = b, a
        return Add(a, b)
    raise TypeError(e)

def solve_single(e: Expr, target: int, env: dict[int,int]) -> bool:
    """Try to solve constraints for a single Var under +c / ^c forms."""
    e = simplify(e, env)
    target &= 0xFF
    if isinstance(e, Const): return (e.v & 0xFF) == target
    if isinstance(e, Var):
        if e.i in env: return (env[e.i] & 0xFF) == target
        env[e.i] = target
        return True
    if isinstance(e, Xor):
        a, b = e.a, e.b
        if isinstance(a, Var) and isinstance(b, Const):
            val = target ^ (b.v & 0xFF)
            if a.i in env: return (env[a.i] & 0xFF) == (val & 0xFF)
            env[a.i] = val & 0xFF
            return True
    if isinstance(e, Add):
        a, b = e.a, e.b
        if isinstance(a, Var) and isinstance(b, Const):
            val = (target - (b.v & 0xFF)) & 0xFF
            if a.i in env: return (env[a.i] & 0xFF) == val
            env[a.i] = val
            return True
    return False

def invert_m(imm: int) -> int:
    # (((val + 13) * 3) & 0xff) ^ 0x55 == imm
    inv3 = 171
    y = (imm ^ 0x55) & 0xFF
    return ((y * inv3) - 13) & 0xFF

def run_vm(variant_byte: int, preset: dict[int,int]):
    bc = bytearray(bytecode0)
    env = {k:(v & 0xFF) for k,v in preset.items()}
    stack: list[Expr] = []
    ip = 0

    for _ in range(50000):
        if not (0 <= ip < len(bc)):
            return ("dead", None)
        op = bc[ip]

        if op == 0x61:  # 'a' nop
            ip += 1
            continue

        if op == 0x65:  # 'e' end
            return ("success", env)

        if op == 0x48:  # 'H' push imm
            ip += 1
            stack.append(Const(bc[ip]))
            ip += 1
            continue

        if op == 0x49:  # 'I' push encoded_input[idx]
            ip += 1
            stack.append(Var(bc[ip]))
            ip += 1
            continue

        if op == 0x55:  # 'U' add
            a = stack.pop(); b = stack.pop()
            stack.append(simplify(Add(a, b), env))
            ip += 1
            continue

        if op == 0x52:  # 'R' xor
            a = stack.pop(); b = stack.pop()
            stack.append(simplify(Xor(a, b), env))
            ip += 1
            continue

        if op == 0x41:  # 'A' assert eq imm
            ip += 1
            imm = bc[ip]
            val = stack.pop()
            if not solve_single(val, imm, env):
                return ("dead", None)
            ip += 1
            continue

        if op == 0x6D:  # 'm' assert transform
            ip += 1
            imm = bc[ip]
            val = stack.pop()
            if not solve_single(val, invert_m(imm), env):
                return ("dead", None)
            ip += 1
            continue

        if op == 0x69:  # 'i' jump by (top ^ imm)
            ip += 1
            imm = bc[ip]
            top = simplify(stack.pop(), env)
            if not isinstance(top, Const):
                if isinstance(top, Var):
                    return ("need", (ip, imm, top.i, env))
                return ("dead", None)
            ip = ip + (((top.v & 0xFF) ^ imm) & 0xFFFFFFFF)
            continue

        if op == 0x68:  # 'h' timing xor 4 bytes
            ip += 1
            for j in range(4):
                bc[ip+j] ^= variant_byte
            continue

        if op == 0x74:  # 't' xor-block
            ip += 1
            n = bc[ip]; ip += 1
            key = bc[ip]; ip += 1
            for j in range(n):
                bc[ip+j] ^= key
            continue

        return ("dead", None)

    return ("dead", None)

def invert_encode_input(encoded: bytes) -> bytes:
    state = 0xA7
    out = bytearray()
    for i, e in enumerate(encoded):
        b = ((e - (13*i)) & 0xFF) ^ state
        out.append(b)
        state = (e ^ ((state * 7) & 0xFF)) & 0xFF
    return bytes(out)

# BFS: isi byte yang diperlukan saat jump muncul
q = collections.deque()
q.append({})
seen = set()

def solve_with_variant(variant: int) -> str | None:
    q = collections.deque([{}])
    seen = set()

    while q:
        preset = q.popleft()
        key = tuple(sorted(preset.items()))
        if key in seen:
            continue
        seen.add(key)

        st, payload = run_vm(variant, preset)
        if st == "success":
            env = payload
            # flag length = 44; ini yang dipakai VM untuk modulo dan output
            if all(i in env for i in range(44)):
                encoded = bytes(env[i] for i in range(44))
                return invert_encode_input(encoded).decode("ascii")

        if st == "need":
            _, imm, idx, env_snapshot = payload
            # brute 0..255 untuk encoded_input[idx], lanjutkan yang masih hidup
            for v in range(256):
                p2 = dict(preset)
                p2[idx] = v
                st2, _ = run_vm(variant, p2)
                if st2 in ("success", "need"):
                    q.append(p2)

    return None

# opcode 'h' memilih XOR key via rdtsc, kadang 0xCC kadang 0xAD.
for variant in (0xCC, 0xAD):
    flag = solve_with_variant(variant)
    if flag is not None:
        print(flag)
        raise SystemExit(0)

raise SystemExit("failed to recover flag")
```

Abis itu jalanin:

```bash
$ python3 solve.py
ARKAV{C4nn07_5p311_h1ur4_m1h473_w17h0u7_H1M}
```

---

### Validasi

Begitu solver ngeluarin string flag, validasinya cuma ini:

```bash
$ ./him 'ARKAV{C4nn07_5p311_h1ur4_m1h473_w17h0u7_H1M}'

FLAG: ARKAV{C4nn07_5p311_h1ur4_m1h473_w17h0u7_H1M}
```

Exit code `0` juga jadi indikator kita lolos semua jalur “kalau salah -> rusak -> crash”.

---

## NeuralChiper

### Intro

Ada tiga file, satu klaim besar: *“neural network cipher”*. Dan jujur ya—kalau sebuah “cipher” ngaku-ngaku neural network, biasanya ujungnya entah:

- cuma *linear layer* doang,
- atau obfuscation supaya kita lupa kalau matematika masih berlaku.

Challenge ini jatuh ke kategori pertama. Cantik, cepat, dan… **reversible**.

Target kita sederhana: dari `output` yang “terenkripsi”, balikin lagi ke input aslinya sampai ketemu flag.

---

### Recon: apa aja isi dist?

Mulai dari zip-nya:

```bash
$ ls -la
dist.zip

$ unzip -l dist.zip
Archive:  dist.zip
  Length      Date    Time    Name
---------  ---------- -----   ----
      178  2026-01-28 22:38   output
    10944  2026-01-28 22:38   weights
     4137  2026-01-28 22:38   chall.pyc
---------                     -------
    15259                     3 files
```

Tiga artefak:

- `output` → hasil “ciphertext”
- `weights` → bobot model (curiga ini matrix)
- `chall.pyc` → kernel AI “bocor” (tapi dibikin ngeselin)

---

### Ngelirik `output`: ini bytes yang disamarkan

`output` ternyata cuma daftar angka per baris:

```bash
$ wc -l output
52 output

$ head -n 8 output
2
218
41
57
208
54
224
95
```

52 angka, masing-masing 0–255. Ini sudah bau “vektor byte”.

---

### Ngelirik `weights`: NUMPY, shape (52, 52)

File `weights` kelihatan seperti `.npy`:

```bash
$ hexdump -C weights | head
00000000  93 4e 55 4d 50 59 01 00  76 00 7b 27 64 65 73 63  |.NUMPY..v.{'desc|
00000010  72 27 3a 20 27 3c 69 34  27 2c 20 27 66 6f 72 74  |r': '<i4', 'fort|
00000020  72 61 6e 5f 6f 72 64 65  72 27 3a 20 46 61 6c 73  |ran_order': Fals|
00000030  65 2c 20 27 73 68 61 70  65 27 3a 20 28 35 32 2c  |e, 'shape': (52,|
00000040  20 35 32 29 2c 20 7d 20  20 20 20 20 20 20 20 20  | 52), }         |
```

Di header keliatan jelas:

- dtype: `'<i4'` (int32)
- shape: `(52, 52)`

Kalau ini “neural network cipher”, kemungkinan besar ini cuma:

> `y = W * x (mod 256)`

di mana:

- `x` = input (52 byte)
- `W` = weight matrix (52×52)
- `y` = output (52 angka yang kita pegang)

Alias: satu *fully-connected layer* tanpa aktivasi. Dan kalau `W` invertible modulo 256… game over.

---

### Bonus: `chall.pyc` itu jebakan (tapi gak perlu)

Kalau coba jalanin langsung:

```bash
$ python3 chall.pyc
RuntimeError: Bad magic number in .pyc file
```

Itu karena header `.pyc`-nya dimodif (magic number-nya beda). Secara teknis masih bisa di-*load* dengan `marshal` setelah skip 16 byte header, tapi di challenge ini kita bahkan gak butuh full decompile—dua file data (`weights` + `output`) sudah cukup buat “balikin network”-nya.

Kalau mau lihat “alamat”-nya (offset file), ini 16 byte pertama `chall.pyc`:

```bash
$ hexdump -C chall.pyc | head -n 2
00000000  42 0f ad ed 00 00 00 00  76 2d 7a 69 4b 0e 00 00  |B.......v-ziK...|
00000010  e3 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
```

Di offset `0x00000000` kelihatan magic number `42 0f ad ed` (beda dari magic Python normal), makanya interpreter nolak.

Contoh load code object (kalau pengen ngintip):

```python
import marshal, dis
with open("chall.pyc","rb") as f:
    f.read(16)
    code = marshal.load(f)
dis.dis(code)
```

---

### Inti exploit: invert matrix modulo 256

Kalau encrypt-nya linear:

```
y = W * x  (mod 256)
```

maka decrypt-nya tinggal:

```
x = W^{-1} * y  (mod 256)
```

Syaratnya cuma satu: `W` harus punya inverse modulo 256.

Quick sanity check yang enak: lihat rank matrix modulo 2. Kalau full-rank (52), berarti `det(W)` ganjil (unit di `Z/256Z`) → **W pasti invertible modulo 256**.

```python
import numpy as np
w = np.load("weights")
print("shape:", w.shape, "dtype:", w.dtype)
print("mod2 rank:", np.linalg.matrix_rank(w % 2))
```

```bash
shape: (52, 52) dtype: int32
mod2 rank: 52
```

Full rank. Mantap.

---

### Solver: 10 baris yang bikin “AI cipher” jadi plaintext

Kita pakai `sympy` buat inverse modulo 256 (`inv_mod(256)`):

```python
import numpy as np
import sympy as sp

w = np.load("weights")
y = [int(line) for line in open("output")]

W = sp.Matrix(w.tolist())
Y = sp.Matrix(y)

X = (W.inv_mod(256) * Y) % 256
pt = bytes(int(v) for v in list(X))
print(pt.decode())
```

### Flag

`ARKAV{m4tr1x_m0dul0_m4yhem_1nv3rt1bl3_n3ur4l_c1ph3r}`

Dan selesai.

---


## umapyoi

### Intro

Deskripsinya: *“Are you... glad to have been my trainer?”*  
Binarynya cuma ngasih prompt `Insert flag:` lalu kalau salah, kita langsung dicap:

> `Your trainee lacks guts.`

Yang bikin menarik: ini bukan “string compare doang”, tapi sebuah **graf** berukuran 1000 node, dan flag yang benar adalah **jalur** dari node start ke node end dengan panjang yang tepat.

Write-up ini aku ceritain dari recon sampai dapat flag.

---

### Recon: lihat binary-nya dulu

Unzip, cek tipe file, lalu coba jalanin:

```bash
$ unzip -o umapyoi.zip
$ file umapyoi
umapyoi: ELF 64-bit LSB executable, x86-64, statically linked, ... not stripped

$ ./umapyoi
I'm going to win this for the folks back home. But first, food.
Insert flag:
```

Kalau aku masukin string random:

```bash
$ printf '%s\n' test | ./umapyoi
...
Your trainee lacks guts.
```

Karena binary **not stripped**, aku langsung cari simbol `main`:

```bash
$ nm -n umapyoi | rg ' main$'
0000000000405589 T main
```

---

### Membaca `main`: validasi input dan “mesin pencetak flag”

Disassemble `main`:

```bash
$ objdump -d -M intel --disassemble=main umapyoi | sed -n '1,120p'
```

Hal penting yang kelihatan dari `main` (alamat: `0x405589`):

1. Print narasi + prompt.
2. Baca input sebagai `std::string`.
3. Panggil fungsi `init(input)` (alamat: `0x405146`).
4. Kalau `init` gagal **atau** `length != 0x22` (34), langsung exit dengan “lacks guts”.
5. Kalau lolos, program bikin sebuah `std::function` (lambda rekursif) dan mulai traversal graf dari node start.

Dua angka kunci juga keliatan “hard-coded” di `main`:

- `start = 0x278` (632)
- `end   = 0x2cb` (715)

---

### `init(input)`: bukan cari flag, cuma “cek karakter”

Disassemble `init`:

```bash
$ objdump -d -M intel --disassemble=_Z4initRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE umapyoi | sed -n '1,120p'
```

Di `init` (alamat: `0x405146`) aku nemu string whitelist karakter di `.rodata`:

```bash
$ strings -t x -n 5 umapyoi | rg '0134579AKRV'
181040 0134579AKRV_bdmnruv{}
```

Intinya, `init` bikin `unordered_set<char>` dari whitelist itu, lalu memastikan **setiap** karakter input ada di set tersebut.

Pseudocode hasil konversi ASM → logika:

```c
bool init(const string& s) {
  const string allowed = "0134579AKRV_bdmnruv{}";
  unordered_set<char> set(allowed.begin(), allowed.end());

  for (char c : s) {
    if (set.find(c) == set.end()) return false;
  }
  return true;
}
```

Jadi… `init` bukan pembanding flag. Dia cuma “pagar” biar input kita pakai alphabet tertentu.

---

### Lambda rekursif di `main`: flag = jalur di graf

Lambda yang dipakai `std::function` ada simbolnya (karena not stripped):

```bash
$ nm umapyoi | rg '_ZZ4main.*_clEiiS4_'
000000000040533a t _ZZ4mainENKUliiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE_clEiiS4_
```

Disassemble lambda itu (alamat: `0x40533a`):

```bash
$ objdump -d -M intel --disassemble=_ZZ4mainENKUliiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE_clEiiS4_ umapyoi | sed -n '1,220p'
```

Struktur logikanya:

- Parameter `i` = node saat ini.
- Parameter `depth` = indeks karakter yang sedang dicek (0..len-1).
- Parameter `out` = string yang sedang dikumpulkan.
- Ada `found` flag supaya stop saat sudah ketemu.
- Ada dua global penting:
  - `node_chars` (`0x5f3d20`): map `node -> char`
  - `graph` (`0x5f3ce0`): map `node -> vector<neighbor>`

Potongan verifikasi karakter (yang jadi “kunci puzzle”-nya):

1) Ambil `expected = node_chars[i]`  
2) Cek `input[depth] == expected`  
3) Kalau sama, append `expected` ke `out`  
4) Kalau `depth == len-1` dan `i == end`, print `FLAG: ` + `out`

Kalau di buat Pseudocode ringkasnya gini:

```c
void dfs(int node, int depth, string out) {
  if (depth >= input.size()) return;
  if (input[depth] != node_chars[node]) return;

  out.push_back(node_chars[node]);

  if (depth == input.size() - 1 && node == end) {
    cout << "FLAG: " << out << endl;
    found = true;
    return;
  }

  for (int nxt : graph[node]) {
    if (found) return;
    dfs(nxt, depth + 1, out);
  }
}
```

Ini menjelaskan kenapa program bisa *“print flag”* tanpa pernah menyimpan string flag final secara literal:  
**flag adalah hasil traversal**, dan input kita dipakai untuk “mengunci” pilihan node per depth.

Sampai sini, problemnya jadi jelas:

> Cari string panjang 34, semua karakter dari whitelist, yang merepresentasikan jalur node `0x278 -> ... -> 0x2cb` sepanjang 33 edge, dengan aturan `char(depth) = node_chars[node]`.

---

### Menghindari RE yang capek: ekstrak tabel graf langsung dari file

Aku sempat lihat inisialisasi globalnya yang panjang banget di `__static_initialization_and_destruction_0` (sekitar `0x405cfe`), tapi itu bakal bikin write-up jadi sinetron 1000 episode.

Yang lebih cepat: karena ini binary statik dan datanya dibangun dari konstanta di `.rodata`, kita bisa **dump tabelnya langsung dari file**.

Dua offset yang relevan (file offset, bukan address runtime):

- `node_chars` table: `0x188f00` (1000 entry, format `<int node><int char>` = 8 byte per entry)
- `graph` adjacency: `0x1811f0` (1000 node, tiap node punya 5 neighbor `int32` = 0x20 byte per node)

Aku verifikasi salah satunya dengan hexdump:

```bash
$ hexdump -Cv -s 0x188f00 -n 64 umapyoi
00188f00  00 00 00 00 4e 00 00 00  01 00 00 00 70 00 00 00  |....N.......p...|
...
```

Artinya:

- node 0 → 'N' (0x4e)
- node 1 → 'p' (0x70)
- dst.

---

### “Exploit”-nya: cari path panjang 34 yang masuk akal (`ARKAV{...}`)

Kita tahu format flag CTF nya `ARKAV{...}`.  
Kebetulan, jalur shortest yang ketemu duluan memang mulai dengan `A` dari node start, jadi aku pakai prefix ini untuk mempersempit pencarian.

Strateginya:

1) Extract `node_chars[0..999]` dan `adj[0..999][0..4]`.
2) Dynamic programming: `reachable[t]` = set node yang bisa mencapai `end` dalam tepat `t` langkah.
3) Paksa prefix `ARKAV{` di awal.
4) Reconstruct sisanya hingga panjang tepat 34.

Solver yang aku pakai:

```py
import struct

BIN = "umapyoi"
NODE_CHARS_OFF = 0x188f00
GRAPH_OFF      = 0x1811f0
N = 1000

START = 0x278
END   = 0x2cb
L     = 34
EDGES = L - 1

with open(BIN, "rb") as f:
  f.seek(NODE_CHARS_OFF)
  node_data = f.read(N * 8)

node_char = ["?"] * N
for i in range(N):
  k, v = struct.unpack_from("<iI", node_data, i * 8)
  assert k == i
  node_char[i] = chr(v & 0xff)

with open(BIN, "rb") as f:
  f.seek(GRAPH_OFF)
  graph_data = f.read(N * 0x20)

adj = [None] * N
for i in range(N):
  adj[i] = list(struct.unpack_from("<5i", graph_data, i * 0x20))

# DP: reachable[t] = nodes that can reach END in exactly t edges
reachable = [set() for _ in range(EDGES + 1)]
reachable[0].add(END)
for t in range(1, EDGES + 1):
  prev = reachable[t - 1]
  cur = set()
  for u in range(N):
    if any(v in prev for v in adj[u]):
      cur.add(u)
  reachable[t] = cur

assert START in reachable[EDGES]

prefix = "ARKAV{"
paths = [(START, [START])]
for ch in prefix[1:]:
  nxt = []
  for u, p in paths:
    for v in adj[u]:
      if node_char[v] == ch:
        nxt.append((v, p + [v]))
  paths = nxt
assert paths, "prefix not found"

best = None
for u, p in paths:
  remaining = EDGES - (len(prefix) - 1)
  if u in reachable[remaining]:
    best = p
    break
assert best is not None

cur = best[-1]
remaining = EDGES - (len(best) - 1)
while remaining > 0:
  for v in adj[cur]:
    if v in reachable[remaining - 1]:
      best.append(v)
      cur = v
      remaining -= 1
      break
  else:
    raise RuntimeError("stuck")

flag = "".join(node_char[n] for n in best)
print(flag)
```

Jalankan:

```bash
$ python3 solve.py
ARKAV{09ur1_d_b3_7r4v3r51n9_1n_m3}
```

Verifikasi ke binary:

```bash
$ printf '%s\n' 'ARKAV{09ur1_d_b3_7r4v3r51n9_1n_m3}' | ./umapyoi
...
FLAG: ARKAV{09ur1_d_b3_7r4v3r51n9_1n_m3}
```

